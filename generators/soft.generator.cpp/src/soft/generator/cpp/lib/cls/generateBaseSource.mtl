[comment encoding = UTF-8 /]
[module generateBaseSource('http://www.eclipse.org/emf/2002/Ecore')]

[import soft::generator::common::generateCommon/]
[import soft::generator::common::generateElement/]
[import soft::generator::cpp::generateCommon /]
[import soft::generator::cpp::generateOperation/]
[import soft::generator::cpp::generateType/]
[import soft::generator::cpp::generateStructuralFeature /]
[import soft::generator::cpp::lib::generateCommon /]
[import soft::generator::cpp::lib::generateInterface /]
[import soft::generator::cpp::lib::cls::generateReflectives /]


[template public generateBaseSource(aClass : EClass) { className : String = aClass.getBaseImplementationName(); namespaceName : String = aClass.ePackage.getImplementationNamespaceName(); guardName : String = '_'.concat(className);}]
[file (aClass.ePackage.getOutputDirectory() + '/src-gen/' + aClass.ePackage.getImplementationFolder() + '/' + className + '.inl', false, 'UTF-8')]
[fileComment()/]

#ifndef [getGuardName(guardName)/]
#error This file may only be included from [className/].hpp
#endif

[let includes : OrderedSet(String) = Set{ aClass.getReferencedTypes()->selectByKind(EClass)->collect( c | c.getInclude())->asSet()
                                        , Set { 
                                                '"ecore/Any.hpp"',
                                                '"ecore/AnyCast.hpp"',
                                                '"ecore/EClass.hpp"',
                                                '"ecore/impl/EObjectEList.hpp"' 
                                              }
                                        , Set {
                                                aClass.ePackage.getQualifiedInterfaceName(),
                                                aClass.ePackage.getFactoryQualifiedInterfaceName(),
                                                aClass.eClass().ePackage.getQualifiedInterfaceName(),
                                                aClass.eClass().ePackage.getFactoryQualifiedInterfaceName()
                                              }-> collect( c | '"' + namespaceToFolder(c) + '.hpp"' ) 
                                        }->flatten()->asOrderedSet()->sortedBy( s | s)]
[for ( include : String | includes )]
#include [include/]
[/for]
[/let]

#include <cassert>
#include <iostream>
#include <sstream>

//[protected (className + ' [definition-includes]')]
//[/protected]

//[protected (className + ' [definition-begin]')]
//[/protected]

namespace [namespaceName/] 
{

    //*********************************
    // Constructor / Destructor
    //*********************************
    template <typename... I>
    [className/]<I...>::[className/]()
    [let dataFeatures : OrderedSet(EStructuralFeature) = aClass.eStructuralFeatures->select(isField())]
    [for ( aFeature : EStructuralFeature | dataFeatures ) before(':') separator(',')]
       [aFeature.generateDataInitialization()/]
    [/for]
    [/let]
    //[protected (className+ '::' + className)]
    {
    }
    //[/protected]

    template <typename... I>
    [className/]<I...>::~[className/]()
    {
    [if not aClass.ePackage.eClassifiers->exists( c | c.oclIsKindOf(EClass) and c <> aClass and aClass.isSuperTypeOf(c.oclAsType(EClass)))]
    #ifdef SHOW_DELETION
        std::string name;
        if ( auto named = dynamic_cast<ENamedElement*>( this ) )
            name = named->getName();
        std::cout << "delete [className/] ['['/]"<< this << "[']'/] " << name << std::endl;
    #endif
    [/if]
    //[protected (className+ '::~' + className)]
    //[/protected]
    }

    template <typename... I>
    std::shared_ptr<[className/]<I...>> [className/]<I...>::[getThisPtrGetterName()/]() const
    {
        return [getThisPtrName()/]_.lock();
    }
    
    template <typename... I>
    void [className/]<I...>::[getThisPtrSetterName()/](const std::shared_ptr<[className/]>& [getThisPtrName()/])
    {
        [removeNamespace(aClass.getClassExtends())/]::[getThisPtrSetterName()/]([getThisPtrName()/]);
        [getThisPtrName()/]_ = [getThisPtrName()/];
    [let dataFeatures : OrderedSet(EStructuralFeature) = aClass.eStructuralFeatures->select(isField()) ]
        [dataFeatures.generateDataInitializationDefered()/]
    [/let]
    }

    template <typename... I>
    std::shared_ptr<EClass> [className/]<I...>::eStaticClass() const
    {
        return [aClass.ePackage.getInterfaceName()/]::eInstance()->get[aClass.getElementAccessorName()/]();
    }

[let operations : OrderedSet(EOperation) = aClass.eOperations->select( isPublic(true) )]
[if operations->notEmpty()]
    //*********************************
    // Operations
    //*********************************
    [operations.generateDefinition()/]
[/if]
[/let]
[let attributes : OrderedSet(EAttribute) = aClass.eStructuralFeatures->selectByKind(EAttribute)->select( hasSetter('public',true) or hasGetter('public',true) )]
[if attributes->notEmpty()]
    //*********************************
    // Attributes
    //*********************************
    [attributes.generateDefinition()/]
[/if]
[/let]
[let references : OrderedSet(EAttribute) = aClass.eStructuralFeatures->selectByKind(EReference)->select( hasSetter('public',true) or hasGetter('public',true)  )]
[if references->notEmpty()]
    //*********************************
    // References
    //*********************************
    [references.generateDefinition()/]
[/if]
[/let]
[let basicFeatures : OrderedSet(EAttribute) = aClass.eStructuralFeatures->select( isBasicGet() or isBasicSet() )]
[if basicFeatures->notEmpty()]
    //*********************************
    // Basics
    //*********************************
    [basicFeatures.generateBasicDefinition()/]
[/if]
[/let]
[aClass.generateReflectivesDefinition()/]
[let dataFeatures : OrderedSet(EStructuralFeature) = aClass.getDataInitializationFeatures()]
[if dataFeatures->notEmpty()]
    //*********************************
    // Initializations
    //*********************************
    [dataFeatures.generateDataInitializationMethodDefinition()/]
[/if]
[/let]

}

// [protected (className + ' [definition-end]') ]
// [/protected]

[/file]
[/template]
