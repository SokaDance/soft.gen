[comment encoding = UTF-8 /]
[module generateImplementationHeader('http://www.eclipse.org/emf/2002/Ecore')]

[import soft::generator::common::generateCommon/]
[import soft::generator::cpp::generateOperation /]
[import soft::generator::cpp::generateType /]
[import soft::generator::cpp::generateCommon /]
[import soft::generator::cpp::generateStructuralFeature /]
[import soft::generator::cpp::lib::generateCommon /]
[import soft::generator::cpp::lib::impl::generateReflectives /]

[template public generateImplementationHeader(aClass : EClass){ classBaseName : String = aClass.getBaseImplementationName() ; classImplName : String = aClass.getImplementationName(); namespaceName : String = aClass.ePackage.getImplementationNamespaceName(); guardName : String = '_'.concat(classImplName); }]
[file (aClass.ePackage.getOutputDirectory() + '/src-gen/' + aClass.ePackage.getImplementationFolder() + '/' + classImplName +'.hpp', false, 'UTF-8')]
[fileComment()/]
[startGuard(guardName)/]

[if aClass.isExported()]
#include "[aClass.ePackage.getInterfaceFolder()/]/Exports.hpp"
[/if]
[for (implInclude : String | aClass.getClassImplements()->asOrderedSet()->sortedBy(s | s))]
#include "[namespaceToFolder(implInclude)/].hpp"
[/for]
#include "[namespaceToFolder(aClass.getClassExtends())/].hpp"
[if aClass.eStructuralFeatures->exists( isLazy())]
#include "ecore/impl/Lazy.hpp"
[/if]
[if aClass.eStructuralFeatures->exists( isProxy())]
#include "ecore/impl/Proxy.hpp"
[/if]

// [protected (classImplName + ' [declaration-includes]')]
// [/protected]

namespace [namespaceName/] 
{
    template <typename... I>
    class [classBaseName/] : public [getShortQualifiedName(aClass.getClassExtends(),namespaceName)/]<I...> 
    {
    private:
        [classBaseName/]& operator=([classBaseName/] const&) = delete;
    
    protected:
        friend class [ aClass.ePackage.getFactoryImplementationName() /];
        [classBaseName/]();
        std::shared_ptr<[classBaseName/]> [getThisPtrGetterName()/]() const;
        void [getThisPtrSetterName()/](const std::shared_ptr<[classBaseName/]>& [getThisPtrName()/]);

    public:
        virtual ~[classBaseName/]();
        
[let operations : OrderedSet(EOperation) = aClass.eOperations->select( isPublic(true) )]
[if operations->notEmpty()]
        //*********************************
        // Operations
        //*********************************
        [operations.generateDeclaration(true)/]
[/if]
[/let]
[let attributes : OrderedSet(EAttribute) = aClass.eStructuralFeatures->selectByKind(EAttribute)->select( hasSetter('public',true) or hasGetter('public',true) )]
[if attributes->notEmpty()]
        //*********************************
        // Attributes
        //*********************************
        [attributes.generateDeclaration(true)/]
[/if]
[/let]
[let references : OrderedSet(EAttribute) = aClass.eStructuralFeatures->selectByKind(EReference)->select( hasSetter('public',true) or hasGetter('public',true)  )]
[if references->notEmpty()]
        //*********************************
        // References
        //*********************************
        [references.generateDeclaration(true)/]
[/if]
[/let]

    protected:
        virtual std::shared_ptr<[getShortQualifiedName('ecore::EClass',namespaceName)/]> eStaticClass() const;
[let basicFeatures : OrderedSet(EAttribute) = aClass.eStructuralFeatures->select( isBasicGet() or isBasicSet() )]
[if basicFeatures->notEmpty()]

        //*********************************
        // Basics
        //*********************************
        [basicFeatures.generateBasicDeclaration()/]
[/if]
[/let]

        [aClass.generateReflectivesDeclaration()/]

[let dataInitializationFeatures : OrderedSet(EStructuralFeature) = aClass.getDataInitializationFeatures()]
[if dataInitializationFeatures->notEmpty()]
        //*********************************
        // Initializers
        //*********************************
        [dataInitializationFeatures.generateDataInitializationMethodDeclaration()/]
[/if]
[/let]

[let dataDeclarationFeatures : OrderedSet(EAttribute) = aClass.eStructuralFeatures->select( isField() )]
[if dataDeclarationFeatures->notEmpty()]
    protected:
        [dataDeclarationFeatures.generateDataDeclaration()/]
[/if]
[/let]
    private:
        std::weak_ptr<[classBaseName/]> [getThisPtrName()/]_;
    
        // [protected (classImplName + ' [declaration-methods]')]
        // [/protected]
    };

	typedef [classBaseName/]<[for ( implClass : String | aClass.getClassImplements()->asOrderedSet()->sortedBy(s | s)) separator (',')][getShortQualifiedName(implClass, namespaceName)/][/for]> [classImplName/];

}

#include "[aClass.ePackage.getImplementationFolder() + '/' + classImplName +'.inl'/]"

[endGuard(guardName)/]
[/file]
[/template]
