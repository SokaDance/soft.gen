[comment encoding = UTF-8 /]
[module generateImplementationTest('http://www.eclipse.org/emf/2002/Ecore')/]

[import soft::generator::go::generateCommon/]
[import soft::generator::go::generateType/]
[import soft::generator::go::test::generateType/]
[import soft::generator::go::lib::generateCommon/]
[import soft::generator::go::lib::generateReflectives/]
[import soft::generator::go::lib::generateOperation/]
[import soft::generator::go::lib::generateStructuralFeature/]
[import soft::generator::common::generateCommon/]
[import soft::generator::common::generateReflectives/]

[template public generateImplementationTest(aClass : EClass) { implementationName : String = aClass.getImplementationName(); aPackage : EPackage = aClass.ePackage } ]
[file (aClass.ePackage.getOutputDirectory() + '/' + aClass.getImplementationTestFileName( aClass.name ), false, 'UTF-8')]
[fileComment()/]

package [aPackage.name/]

import (
	"testing"
	"time"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/mock"
	[if not aPackage.isEcorePackage()]"github.com/masagroup/soft/go/ecore"[/if]
)

func discard[name.toUpperFirst()/]() {
	_ = assert.Equal
	_ = mock.Anything
	_ = testing.Coverage
	[if not aPackage.isEcorePackage()]_ = ecore.ADD[/if]
	_ = time.Now()
}

[aClass.eStructuralFeatures->select(isField()).generateTestImplementation(aClass)/]
[aClass.eOperations->select(isDefault()).generateTestOperation()/]
[/file]
[/template]

[template private generateTestOperation(anEOperation : EOperation)]
func Test[anEOperation.eContainingClass.name.toUpperFirst()/][anEOperation.getFunctionName()/]Operation(t *testing.T) {
	obj := [anEOperation.eContainingClass.getConstructorName()/]()
	assert.Panics(t, func() { obj.[anEOperation.getFunctionName()/]([anEOperation.generateParameterListNames()/]) })
}

[/template]

[template private generateTestImplementation(aStructuralFeature : EStructuralFeature, aClass : EClass )]
[if isGet() and isSet() and not isBidirectional() and not isContains()]
[aStructuralFeature.generateGetSetTestImplementation(aClass)/]
[/if]
[if isSet()]
[aStructuralFeature.generateSetTestImplementation(aClass)/]
[/if]
[if isGet() and isListType()]
[aStructuralFeature.generateGetListTestImplementation(aClass)/]
[/if]
[if aClass.getEGetFeatures()->notEmpty()]
[aStructuralFeature.generateEGetTestImplementation(aClass)/]
[/if]
[if aClass.getEInvokeOperations()->notEmpty()]
[aStructuralFeature.generateEInvokeTestImplementation(aClass)/]
[/if]
[if aClass.getEIsSetFeatures()->notEmpty()]
[aStructuralFeature.generateEIsSetTestImplementation(aClass)/]
[/if]
[if aClass.getEUnSetFeatures()->notEmpty()]
[aStructuralFeature.generateEUnSetTestImplementation(aClass)/]
[/if]
[if aClass.getESetFeatures()->notEmpty()]
[aStructuralFeature.generateESetTestImplementation(aClass)/]
[/if]
[if aClass.getEInverseAddFeatures()->notEmpty()]
[aStructuralFeature.generateEInverseAddTestImplementation(aClass)/]
[/if]
[if aClass.getEInverseRemoveFeatures()->notEmpty()]
[aStructuralFeature.generateEInverseRemoveTestImplementation(aClass)/]
[/if]
[/template]

[template private generateGetSetTestImplementation(aStructuralFeature : EStructuralFeature,aClass : EClass)]
[let varName : String = aStructuralFeature.getVariableName() ]
[let varAssigned : String = aStructuralFeature.getUnitTestType() ]
func Test[aClass.name.toUpperFirst()/][name.toUpperFirst()/]Get(t *testing.T) {
	obj := [aClass.getConstructorName()/]()
	obj.[aStructuralFeature.getSetterName()/]([varAssigned/])
	assert.Equal(t, [varAssigned/], obj.[aStructuralFeature.getGetterName()/]())
}
[/let]
[/let]
[/template]

[template private generateSetTestImplementation(aStructuralFeature : EStructuralFeature,aClass : EClass)]
[let varName : String = aStructuralFeature.getVariableName() ]
[let varAssigned : String = aStructuralFeature.getUnitTestType() ]
func Test[aClass.name.toUpperFirst()/][name.toUpperFirst()/]Set(t *testing.T) {
	obj := [aClass.getConstructorName()/]()
	mockAdapter := &[if not aClass.ePackage.isEcorePackage()]ecore.[/if]MockEAdapter{}
	mockAdapter.On("SetTarget",obj).Once()		
	mockAdapter.On("NotifyChanged", mock.Anything).Once()
	obj.EAdapters().Add(mockAdapter)
	obj.[aStructuralFeature.getSetterName()/]([varAssigned/])
	mockAdapter.AssertExpectations(t)
}
[/let]
[/let]
[/template]

[template private generateUnsetTestImplementation(aStructuralFeature : EStructuralFeature,aClass : EClass)]
[let varName : String = aStructuralFeature.getVariableName() ]
[let varAssigned : String = aStructuralFeature.getUnitTestType() ]
func Test[aClass.name.toUpperFirst()/][name.toUpperFirst()/]Unset(t *testing.T) {
	obj := [aClass.getConstructorName()/]()
	obj.[aStructuralFeature.getUnSetterName()/]()
[if aStructuralFeature.isListType()]
	assert.Equal(t, 0, obj.[varName/].Size())
[else]
	assert.Equal(t, [aStructuralFeature.eType.getDefaultValue()/], obj.[varName/])
[/if]
}
[/let]
[/let]
[/template]

[template private generateGetListTestImplementation(aStructuralFeature : EStructuralFeature,aClass : EClass)]
[let varName : String = aStructuralFeature.getVariableName() ]
[let varAssigned : String = aStructuralFeature.getUnitTestType() ]
func Test[aClass.name.toUpperFirst()/][name.toUpperFirst()/]GetList(t *testing.T) {
	obj := [aClass.getConstructorName()/]()
	[if aStructuralFeature.eType.name = 'EFeatureMapEntry' or aStructuralFeature.volatile]
	assert.Nil(t, obj.[aStructuralFeature.getGetterName()/]())
	[else]
	assert.NotNil(t, obj.[aStructuralFeature.getGetterName()/]())
	[/if]
}
[/let]
[/let]
[/template]

[template private generateEGetTestImplementation(aStructuralFeature : EStructuralFeature,aClass : EClass)]
func Test[aClass.name.toUpperFirst()/][name.toUpperFirst()/]EGet(t *testing.T) {
	obj := [aClass.getConstructorName()/]()
	[for (anStructFeature : EStructuralFeature | aClass.eStructuralFeatures->asOrderedSet()->sortedBy(name))]
    {
    [let lazy : String = anStructFeature.getLazy()]
		[if anStructFeature.eType.name = 'EFeatureMapEntry' or anStructFeature.volatile]
		_ = obj
		[elseif not anStructFeature.isContainer() and anStructFeature.isVolatile() and not anStructFeature.hasKey('getterBody')]
		assert.Panics(t, func() { obj.EGetFromID([aClass.getQualifiedIDName(anStructFeature)/], false, false) })
		[elseif not anStructFeature.isContainer() and not anStructFeature.isVolatile() and lazy <> 'no' and lazy = 'action']
		_ = obj
		[else]
		assert.Equal(t, obj.[anStructFeature.getGetterName()/](), obj.EGetFromID([aClass.getQualifiedIDName(anStructFeature)/], false, false))
		[/if]
	[/let]
	}
    [/for]
}

[/template]

[template private generateEInvokeTestImplementation(aStructuralFeature : EStructuralFeature,aClass : EClass)]
func Test[aClass.name.toUpperFirst()/][name.toUpperFirst()/]EInvoke(t *testing.T) {
	obj := [aClass.getConstructorName()/]()
    [for ( eOperation : EOperation | aClass.getEInvokeOperations()->sortedBy(name) )]
    {
		assert.Panics(t, func() { obj.EInvokeFromID([eOperation.eContainingClass.getOperationIDName(eOperation)/], nil) })
	}
    [/for]
}

[/template]

[template private generateEIsSetTestImplementation(aStructuralFeature : EStructuralFeature,aClass : EClass)]
func Test[aClass.name.toUpperFirst()/][name.toUpperFirst()/]EIsSet(t *testing.T) {
	obj := [aClass.getConstructorName()/]()
	[for (anStructFeature : EStructuralFeature | aClass.getEIsSetFeatures()->sortedBy(name))]
	{
		[if anStructFeature.eType.name = 'EFeatureMapEntry' or anStructFeature.volatile]
		_ = obj
		[elseif anStructFeature.isListType()]
		    [if anStructFeature.isField()]
		assert.Equal(t, obj.[anStructFeature.name/] != nil && obj.[anStructFeature.name/].Size() != 0, obj.EIsSetFromID([aClass.getQualifiedIDName(anStructFeature)/]))
		    [else]
		assert.Equal(t, obj.[anStructFeature.getGetterName()/]().Size() != 0, obj.EIsSetFromID([aClass.getQualifiedIDName(anStructFeature)/]))
		    [/if]
		[else]
		    [let accessor : String = if isField() then anStructFeature.getVariableName() else anStructFeature.getGetterName()+'()' endif]
		    [if eType.oclIsKindOf(EEnum)]
		assert.Equal(t, obj.[accessor/] != [anStructFeature.oclAsType(EAttribute).generateDefaultValue()/], obj.EIsSetFromID([aClass.getQualifiedIDName(anStructFeature)/]))
		    [else]
		_ = obj
		    [/if]
		    [/let]
		[/if]
	}
	[/for]
}

[/template]

[template private generateEUnSetTestImplementation(aStructuralFeature : EStructuralFeature,aClass : EClass)]
func Test[aClass.name.toUpperFirst()/][name.toUpperFirst()/]EUnset(t *testing.T) {
	obj := [aClass.getConstructorName()/]()
    [for (anStructFeature : EStructuralFeature | aClass.getEUnSetFeatures()->sortedBy(name))]
	{
    [if anStructFeature.eType.name = 'EFeatureMapEntry' or anStructFeature.volatile]
		_ = obj
	[elseif anStructFeature.isListType() and not anStructFeature.isUnSettable()]
		obj.EUnsetFromID([aClass.getQualifiedIDName(anStructFeature)/])
        obj.[anStructFeature.getGetterName()/]().Clear()
		assert.Equal(t, 0, obj.[anStructFeature.getGetterName()/]().Size())
	[else]
		_ = obj
    [/if]
	}
	[/for]
}

[/template]

[template private generateESetTestImplementation(aStructuralFeature : EStructuralFeature,aClass : EClass)]
func Test[aClass.name.toUpperFirst()/][name.toUpperFirst()/]ESet(t *testing.T) {
	obj := [aClass.getConstructorName()/]()
    [for (anStructFeature : EStructuralFeature | aClass.getESetFeatures()->sortedBy(name))]
	{
	[let varAssigned : String = anStructFeature.getUnitTestType() ]
    [if anStructFeature.eType.name = 'EFeatureMapEntry' or anStructFeature.volatile]
		_ = obj
	[elseif anStructFeature.isListType()]
		elem := [varAssigned/]
		obj.ESetFromID([aClass.getQualifiedIDName(anStructFeature)/], elem)
		assert.Equal(t, 1, obj.[anStructFeature.getGetterName()/]().Size())
		assert.Equal(t, elem, obj.[anStructFeature.getGetterName()/]().Get(0))
	[else]
		_ = obj
    [/if]
	[/let]
	}
	[/for]
}

[/template]

[template private generateEInverseAddTestImplementation(aStructuralFeature : EStructuralFeature,aClass : EClass)]
func Test[aClass.name.toUpperFirst()/][name.toUpperFirst()/]EInverseAdd(t *testing.T) {
	[for ( aFeature : EStructuralFeature | aClass.getEInverseAddFeatures()->sortedBy(name) )]
	{
		[if aFeature.eType.name = 'EFeatureMapEntry' or aFeature.volatile]
		_ = obj
		[elseif aFeature.isListType()]
		obj := [aClass.getConstructorName()/]()
		obj.EBasicInverseAdd(&[if not aClass.ePackage.isEcorePackage()]ecore.[/if]MockEObject{}, [aClass.getQualifiedIDName(aFeature)/], &[if not aClass.ePackage.isEcorePackage()]ecore.[/if]MockENotificationChain{})
		assert.Equal(t, 1, obj.[aFeature.getGetterName()/]().Size())
		[/if]
	}
	[/for]
}

[/template]

[template private generateEInverseRemoveTestImplementation(aStructuralFeature : EStructuralFeature,aClass : EClass)]
func Test[aClass.name.toUpperFirst()/][name.toUpperFirst()/]EInverseRemove(t *testing.T) {
	[for ( aFeature : EStructuralFeature | aClass.getEInverseRemoveFeatures()->sortedBy(name) )]
	{
		[if aFeature.eType.name = 'EFeatureMapEntry' or aFeature.volatile]
		_ = obj
		[elseif aFeature.isListType()]
		obj := [aClass.getConstructorName()/]()
		mock := &[if not aClass.ePackage.isEcorePackage()]ecore.[/if]MockEObject{}
		obj.[aFeature.getGetterName()/]().Add(mock)
		obj.EBasicInverseRemove(mock, [aClass.getQualifiedIDName(aFeature)/], &[if not aClass.ePackage.isEcorePackage()]ecore.[/if]MockENotificationChain{})
		assert.Equal(t, 0, obj.[aFeature.getGetterName()/]().Size())
		[/if]
	}
	[/for]
}

[/template]
