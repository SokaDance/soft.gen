[comment encoding = UTF-8 /]
[module generateImplementationTests('http://www.eclipse.org/emf/2002/Ecore')/]

[import soft::generator::common::generateCommon/]
[import soft::generator::common::generateElement/]
[import soft::generator::common::generateReflectives/]
[import soft::generator::common::generateStructuralFeature/]

[import soft::generator::go::generateCommon/]
[import soft::generator::go::generateType/]

[import soft::generator::go::lib::generateCommon/]
[import soft::generator::go::lib::generateReflectives/]
[import soft::generator::go::lib::generateOperation/]
[import soft::generator::go::lib::generateStructuralFeature/]

[template public generateImplementationTests(aClass : EClass) { 
	implementationName : String = aClass.getImplementationName(); 
	aPackage : EPackage = aClass.ePackage;
	requiresEcore : Boolean = not aPackage.isEcorePackage() and ( aClass.eStructuralFeatures->notEmpty() or aClass.requiresList() );
}]
[file (aClass.ePackage.getOutputDirectory() + '/' + aClass.getImplementationTestFileName( aClass.name ), false, 'UTF-8')]
[fileComment()/]

package [aPackage.name/]



import (
	"testing"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/mock"
[let imports : OrderedSet(String) = Set { if requiresEcore then Set{ getImportForPackage('ecore') } else Set{} endif
										, OrderedSet{aClass.eSuperTypes
              									    ,aClass.getImplementedFeatures().eType}->flatten()->select( cls | not cls.oclIsUndefined() )->collect( cls | aPackage.getImport(cls) )->asSet()
                                        }->flatten()->select( s | s <> '')->asOrderedSet()->sortedBy( s | s) ]
[for ( i : String | imports )]
	"[i/]"
[/for]
[/let]
)

func discard[name.toUpperFirst()/]() {
	_ = assert.Equal
	_ = mock.Anything
	_ = testing.Coverage
[if requiresEcore]
	_ = ecore.ADD
[/if]
}

func Test[aClass.name.toUpperFirst()/]As[aClass.name.toUpperFirst()/](t *testing.T) {
	o := [aClass.getConstructorName()/]()
	assert.Equal(t, o , o.as[aClass.getInterfaceName()/]())
}

func Test[aClass.name.toUpperFirst()/]StaticClass(t *testing.T) {
	o := [aClass.getConstructorName()/]()
	assert.Equal(t, GetPackage().[aClass.getReflectiveGetterName()/]() , o.EStaticClass() )
}

func Test[aClass.name.toUpperFirst()/]FeatureCount(t *testing.T) {
	o := [aClass.getConstructorName()/]()
	assert.Equal(t, [aClass.getFeatureCountIDName()/] , o.EStaticFeatureCount())
}

[aClass.eStructuralFeatures->select(isField()).generateTestImplementation(aClass)/]
[aClass.eOperations->select(isDefault()).generateTestOperation(aClass)/]
[aClass.generateEGetTestImplementation()/]
[aClass.generateESetTestImplementation()/]
[aClass.generateEIsSetTestImplementation()/]
[aClass.generateEUnSetTestImplementation()/]
[aClass.generateEInvokeTestImplementation()/]
[/file]
[/template]



[template private generateTestImplementation(aStructuralFeature : EStructuralFeature, aClass : EClass )]
[if isGet() and isSet() and not isBidirectional() and not isContains()]
[aStructuralFeature.generateGetSetTestImplementation(aClass)/]
[/if]
[if isSet()]
[aStructuralFeature.generateSetTestImplementation(aClass)/]
[/if]
[if isGet() and isListType()]
[aStructuralFeature.generateGetListTestImplementation(aClass)/]
[/if]
[/template]

[template private generateTestOperation(anEOperation : EOperation, aClass : EClass )]
[let aPackage : EPackage = aClass.ePackage ]
func Test[aClass.name.toUpperFirst()/][anEOperation.getOperationName()/]Operation(t *testing.T) {
	o := [aClass.getConstructorName()/]()
	assert.Panics(t, func() { o.[anEOperation.getOperationName()/]([for (eClassifier : EClassifier | anEOperation.eParameters.eType) separator(',')][eClassifier.getDefaultValue()/][/for]) })
}
[/let]
[/template]

[template private generateGetSetTestImplementation(aStructuralFeature : EStructuralFeature,aClass : EClass)]
[let aPackage : EPackage = aClass.ePackage ]
func Test[aClass.name.toUpperFirst()/][aStructuralFeature.name.toUpperFirst()/]Get(t *testing.T) {
	v := [aStructuralFeature.eType.getTestValue(aPackage)/]
	[if not isListType() and isProxy()]
	v.On("EIsProxy").Return(false)
	[/if]
	obj := [aClass.getConstructorName()/]()
	obj.[aStructuralFeature.getSetterName()/](v)
	assert.Equal(t, v, obj.[aStructuralFeature.getGetterName()/]())
}
[/let]
[/template]

[template private generateSetTestImplementation(aStructuralFeature : EStructuralFeature,aClass : EClass)]
[let aPackage : EPackage = aClass.ePackage ]
[let varName : String = aStructuralFeature.getVariableName() ]
func Test[aClass.name.toUpperFirst()/][aStructuralFeature.name.toUpperFirst()/]Set(t *testing.T) {
	obj := [aClass.getConstructorName()/]()
	v := [aStructuralFeature.eType.getTestValue(aPackage)/]	
	mockAdapter := new([getShortQualifiedName('ecore.MockEAdapter',aPackage.name)/])
	mockAdapter.On("SetTarget",obj).Once()		
	mockAdapter.On("NotifyChanged", mock.Anything).Once()
	obj.EAdapters().Add(mockAdapter)
	obj.[aStructuralFeature.getSetterName()/](v)
	mockAdapter.AssertExpectations(t)
}
[/let]
[/let]
[/template]

[template private generateUnsetTestImplementation(aStructuralFeature : EStructuralFeature,aClass : EClass)]
[let varName : String = aStructuralFeature.getVariableName() ]
func Test[aClass.name.toUpperFirst()/][aStructuralFeature.name.toUpperFirst()/]Unset(t *testing.T) {
	o := [aClass.getConstructorName()/]()
	o.[aStructuralFeature.getUnSetterName()/]()
[if aStructuralFeature.isListType()]
	assert.Equal(t, 0, o.[varName/].Size())
[else]
	assert.Equal(t, [aStructuralFeature.eType.getDefaultValue()/], o.[varName/])
[/if]
}
[/let]
[/template]

[template private generateGetListTestImplementation(aStructuralFeature : EStructuralFeature,aClass : EClass)]
[let varName : String = aStructuralFeature.getVariableName() ]
func Test[aClass.name.toUpperFirst()/][aStructuralFeature.name.toUpperFirst()/]GetList(t *testing.T) {
	o := [aClass.getConstructorName()/]()
	[if aStructuralFeature.eType.name = 'EFeatureMapEntry' or aStructuralFeature.isVolatile()]
	assert.Nil(t, o.[aStructuralFeature.getGetterName()/]())
	[else]
	assert.NotNil(t, o.[aStructuralFeature.getGetterName()/]())
	[/if]
}
[/let]
[/template]

[template private generateEGetTestImplementation(aClass : EClass)]
[let features : Set(EStructuralFeature) = aClass.getEGetFeatures()]
[if features->notEmpty()]
func Test[aClass.name.toUpperFirst()/]EGetFromID(t *testing.T) {
	o := [aClass.getConstructorName()/]()
	[for (anStructFeature : EStructuralFeature | features )]
	[if anStructFeature.isVolatile() or ( anStructFeature.hasInitializationMethod() and anStructFeature.oclIsKindOf(EReference) and not anStructFeature.isListType() and not anStructFeature.isProxy() )  ]
	assert.Panics(t, func() { o.EGetFromID([aClass.getQualifiedIDName(anStructFeature)/], false) })
	[else]
	assert.Equal(t, o.[anStructFeature.getGetterName()/](), o.EGetFromID([aClass.getQualifiedIDName(anStructFeature)/], true))
	[if (anStructFeature.isListType() and anStructFeature.oclIsKindOf(EReference))]
	assert.Equal(t, o.[anStructFeature.getGetterName()/]().([if not aClass.ePackage.isEcorePackage()]ecore.[/if]EObjectList).GetUnResolvedList(), o.EGetFromID([aClass.getQualifiedIDName(anStructFeature)/], false))
	[/if]
	[/if]
    [/for]
}
[/if]
[/let]
[/template]

[template private generateESetTestImplementation(aClass : EClass)]
[let aPackage : EPackage = aClass.ePackage ]
[let features : Set(EStructuralFeature) = aClass.getESetFeatures()->select(not(isListType() and eType.name = 'EFeatureMapEntry'))]
[if features->notEmpty()]
[let isMockGenerated : Boolean = isTemplateGenerated('generateMocks')]
func Test[aClass.name.toUpperFirst()/]ESetFromID(t *testing.T) {
	o := [aClass.getConstructorName()/]()
    [for (anStructFeature : EStructuralFeature | features)]
	{
	[if anStructFeature.isListType()]
		[if anStructFeature.isVolatile()]
		assert.Panics(t, func() { o.ESetFromID([aClass.getQualifiedIDName(anStructFeature)/], nil) })
		[else]
		[let isElement : Boolean = isMockGenerated and anStructFeature.eType.oclIsKindOf(EClass)] 
		[if (isElement)]
		e := [anStructFeature.eType.getTestValue(aPackage)/]
		e.On("EIsProxy").Return(false)
		[/if]		
		l := [if not aClass.ePackage.isEcorePackage()]ecore.[/if]NewImmutableEList(['['/][']'/]interface{}{[if (isElement)]e[/if]})
		o.ESetFromID([aClass.getQualifiedIDName(anStructFeature)/], l)
		assert.Equal(t, [if (isElement)]1[else]0[/if], o.[anStructFeature.getGetterName()/]().Size())
		[if (isElement)]
		assert.Equal(t, e, o.[anStructFeature.getGetterName()/]().Get(0))
		[/if]
		[/let]
		[/if]
	[else]
		[if anStructFeature.isVolatile()]
		assert.Panics(t, func() { o.ESetFromID([aClass.getQualifiedIDName(anStructFeature)/], nil) })
		[else]
		v := [anStructFeature.eType.getTestValue(aPackage)/]
		[if anStructFeature.eType.oclIsKindOf(EClass)]
		v.On("EIsProxy").Return(false)
		[/if]
		[if anStructFeature.isContainer()]
		v.On("EResource").Return(nil)
		[/if]		
		o.ESetFromID([aClass.getQualifiedIDName(anStructFeature)/], v)
		assert.Equal(t,v,o.EGetFromID([aClass.getQualifiedIDName(anStructFeature)/], false))
		[/if]
    [/if]
	}
	[/for]
}
[/let]
[/if]
[/let]
[/let]
[/template]

[template private generateEInvokeTestImplementation(aClass : EClass)]
[let operations : Set(EOperation) = aClass.getEInvokeOperations()]
[if aClass.name <> 'EObject' and operations->notEmpty()]
func Test[aClass.name.toUpperFirst()/]EInvokeFromID(t *testing.T) {
	o := [aClass.getConstructorName()/]()
    [for ( eOperation : EOperation | operations )]
    assert.Panics(t, func() { o.EInvokeFromID([eOperation.eContainingClass.getOperationIDName(eOperation)/], nil) })
	[/for]
}
[/if]
[/let]
[/template]

[template private generateEIsSetTestImplementation(aClass : EClass)]
[let features : Set(EStructuralFeature) = aClass.getEIsSetFeatures()]
[if features->notEmpty()]
func Test[aClass.name.toUpperFirst()/]EIsSetFromID(t *testing.T) {
	o := [aClass.getConstructorName()/]()
	[for (anStructFeature : EStructuralFeature | features)]
	{
		[if anStructFeature.eType.name = 'EFeatureMapEntry' or anStructFeature.isVolatile()]
		_ = o
		[elseif anStructFeature.isListType()]
		    [if anStructFeature.isField()]
		assert.Equal(t, o.[anStructFeature.name/] != nil && o.[anStructFeature.name/].Size() != 0, o.EIsSetFromID([aClass.getQualifiedIDName(anStructFeature)/]))
		    [else]
		assert.Equal(t, o.[anStructFeature.getGetterName()/]().Size() != 0, o.EIsSetFromID([aClass.getQualifiedIDName(anStructFeature)/]))
		    [/if]
		[else]
		    [let accessor : String = if isField() then anStructFeature.getVariableName() else anStructFeature.getGetterName()+'()' endif]
		    [if eType.oclIsKindOf(EEnum)]
		assert.Equal(t, o.[accessor/] != [anStructFeature.oclAsType(EAttribute).generateDefaultValue()/], o.EIsSetFromID([aClass.getQualifiedIDName(anStructFeature)/]))
		    [else]
		_ = o
		    [/if]
		    [/let]
		[/if]
	}
	[/for]
}
[/if]
[/let]
[/template]

[template private generateEUnSetTestImplementation(aClass : EClass)]
[let features : Set(EStructuralFeature) = aClass.getEUnSetFeatures()]
[if features->notEmpty()]
func Test[aClass.name.toUpperFirst()/]EUnsetFromID(t *testing.T) {
	o := [aClass.getConstructorName()/]()
    [for (anStructFeature : EStructuralFeature | features)]
	{
    [if anStructFeature.eType.name = 'EFeatureMapEntry' or anStructFeature.isVolatile()]
		_ = o
	[elseif anStructFeature.isListType() and not anStructFeature.isUnSettable()]
		o.EUnsetFromID([aClass.getQualifiedIDName(anStructFeature)/])
        assert.Equal(t, 0, o.[anStructFeature.getGetterName()/]().Size())
	[else]
		_ = o
    [/if]
	}
	[/for]
}
[/if]
[/let]
[/template]



[template private generateEInverseAddTestImplementation(aClass : EClass)]
[let features : OrderedSet(EStructuralFeature) = aClass.getEInverseAddFeatures()->asOrderedSet()->sortedBy(name)]
[if features->notEmpty()]
func Test[aClass.name.toUpperFirst()/]EBasicInverseAdd(t *testing.T) {
	[for ( aFeature : EStructuralFeature | features )]
	{
		[if aFeature.eType.name = 'EFeatureMapEntry' or aFeature.isVolatile()]
		_ = o
		[elseif aFeature.isListType()]
		o := [aClass.getConstructorName()/]()
		o.EBasicInverseAdd(&[if not aClass.ePackage.isEcorePackage()]ecore.[/if]MockEObject{}, [aClass.getQualifiedIDName(aFeature)/], &[if not aClass.ePackage.isEcorePackage()]ecore.[/if]MockENotificationChain{})
		assert.Equal(t, 1, o.[aFeature.getGetterName()/]().Size())
		[/if]
	}
	[/for]
}
[/if]
[/let]
[/template]

[template private generateEInverseRemoveTestImplementation(aClass : EClass)]
[let features : OrderedSet(EStructuralFeature) = aClass.getEInverseRemoveFeatures()->asOrderedSet()->sortedBy(name)]
[if features->notEmpty()]
func Test[aClass.name.toUpperFirst()/]EBasicInverseRemove(t *testing.T) {
	[for ( aFeature : EStructuralFeature | features )]
	{
		[if aFeature.eType.name = 'EFeatureMapEntry' or aFeature.isVolatile()]
		_ = o
		[elseif aFeature.isListType()]
		o := [aClass.getConstructorName()/]()
		mock := &[if not aClass.ePackage.isEcorePackage()]ecore.[/if]MockEObject{}
		o.[aFeature.getGetterName()/]().Add(mock)
		o.EBasicInverseRemove(mock, [aClass.getQualifiedIDName(aFeature)/], &[if not aClass.ePackage.isEcorePackage()]ecore.[/if]MockENotificationChain{})
		assert.Equal(t, 0, o.[aFeature.getGetterName()/]().Size())
		[/if]
	}
	[/for]
}
[/if]
[/let]
[/template]
