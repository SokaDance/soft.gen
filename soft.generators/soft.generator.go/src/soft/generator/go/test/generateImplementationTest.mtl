[comment encoding = UTF-8 /]
[module generateImplementationTest('http://www.eclipse.org/emf/2002/Ecore')/]

[import soft::generator::go::generateCommon/]
[import soft::generator::go::generateType/]
[import soft::generator::go::lib::generateCommon/]
[import soft::generator::go::lib::generateReflectives/]
[import soft::generator::go::lib::generateOperation/]
[import soft::generator::go::lib::generateStructuralFeature/]
[import soft::generator::common::generateCommon/]
[import soft::generator::common::generateElement/]
[import soft::generator::common::generateReflectives/]

[template public generateImplementationTest(aClass : EClass) { implementationName : String = aClass.getImplementationName(); aPackage : EPackage = aClass.ePackage } ]
[file (aClass.ePackage.getOutputDirectory() + '/' + aClass.getImplementationTestFileName( aClass.name ), false, 'UTF-8')]
[fileComment()/]

package [aPackage.name/]



import (
	"testing"
	"time"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/mock"
[let ecorePackage : Set(String) = if not aPackage.isEcorePackage() and ( aClass.eStructuralFeatures->notEmpty() or aClass.requiresList() ) then Set{ getImportForPackage('ecore') } else Set{} endif]
[let imports : OrderedSet(String) = Set { ecorePackage
										, OrderedSet{aClass.eSuperTypes
              									    ,aClass.getImplementedFeatures().eType}->flatten()->select( cls | not cls.oclIsUndefined() )->collect( cls | aPackage.getImport(cls) )->asSet()
                                        }->flatten()->select( s | s <> '')->asOrderedSet()->sortedBy( s | s) ]
[for ( i : String | imports )]
	"[i/]"
[/for]
[/let]
[/let]
)

func discard[name.toUpperFirst()/]() {
	_ = assert.Equal
	_ = mock.Anything
	_ = testing.Coverage
	[if not aPackage.isEcorePackage()]_ = ecore.ADD[/if]
	_ = time.Now()
}

[aClass.eStructuralFeatures->select(isField()).generateTestImplementation(aClass)/]
[aClass.eOperations->select(isDefault()).generateTestOperation(aClass)/]
[aClass.generateEGetTestImplementation()/]
[aClass.generateESetTestImplementation()/]
[aClass.generateEIsSetTestImplementation()/]
[aClass.generateEUnSetTestImplementation()/]
[aClass.generateEInvokeTestImplementation()/]
[/file]
[/template]



[template private generateTestImplementation(aStructuralFeature : EStructuralFeature, aClass : EClass )]
[if isGet() and isSet() and not isBidirectional() and not isContains()]
[aStructuralFeature.generateGetSetTestImplementation(aClass)/]
[/if]
[if isSet()]
[aStructuralFeature.generateSetTestImplementation(aClass)/]
[/if]
[if isGet() and isListType()]
[aStructuralFeature.generateGetListTestImplementation(aClass)/]
[/if]
[/template]

[template private generateTestOperation(anEOperation : EOperation, aClass : EClass )]
[let aPackage : EPackage = aClass.ePackage ]
func Test[aClass.name.toUpperFirst()/][anEOperation.getOperationName()/]Operation(t *testing.T) {
	obj := [aClass.getConstructorName()/]()
	assert.Panics(t, func() { obj.[anEOperation.getOperationName()/]([for (eClassifier : EClassifier | anEOperation.eParameters.eType) separator(',')][eClassifier.getDefaultValue()/][/for]) })
}
[/let]
[/template]

[template private generateGetSetTestImplementation(aStructuralFeature : EStructuralFeature,aClass : EClass)]
[let aPackage : EPackage = aClass.ePackage ]
[let varName : String = aStructuralFeature.getVariableName() ]
func Test[aClass.name.toUpperFirst()/][aStructuralFeature.name.toUpperFirst()/]Get(t *testing.T) {
	var newValue [getShortQualifiedName(aStructuralFeature.eType.getType(),aPackage.name)/] = [aStructuralFeature.eType.getTestValue(aPackage)/]
	obj := [aClass.getConstructorName()/]()
	obj.[aStructuralFeature.getSetterName()/](newValue)
	assert.Equal(t, newValue, obj.[aStructuralFeature.getGetterName()/]())
}
[/let]
[/let]
[/template]

[template private generateSetTestImplementation(aStructuralFeature : EStructuralFeature,aClass : EClass)]
[let aPackage : EPackage = aClass.ePackage ]
[let varName : String = aStructuralFeature.getVariableName() ]
func Test[aClass.name.toUpperFirst()/][aStructuralFeature.name.toUpperFirst()/]Set(t *testing.T) {
	var newValue [getShortQualifiedName(aStructuralFeature.eType.getType(),aPackage.name)/] = [aStructuralFeature.eType.getTestValue(aPackage)/]
	obj := [aClass.getConstructorName()/]()
	mockAdapter := &[getShortQualifiedName('ecore.MockEAdapter',aPackage.name)/]{}
	mockAdapter.On("SetTarget",obj).Once()		
	mockAdapter.On("NotifyChanged", mock.Anything).Once()
	obj.EAdapters().Add(mockAdapter)
	obj.[aStructuralFeature.getSetterName()/](newValue)
	mockAdapter.AssertExpectations(t)
}
[/let]
[/let]
[/template]

[template private generateUnsetTestImplementation(aStructuralFeature : EStructuralFeature,aClass : EClass)]
[let varName : String = aStructuralFeature.getVariableName() ]
func Test[aClass.name.toUpperFirst()/][aStructuralFeature.name.toUpperFirst()/]Unset(t *testing.T) {
	obj := [aClass.getConstructorName()/]()
	obj.[aStructuralFeature.getUnSetterName()/]()
[if aStructuralFeature.isListType()]
	assert.Equal(t, 0, obj.[varName/].Size())
[else]
	assert.Equal(t, [aStructuralFeature.eType.getDefaultValue()/], obj.[varName/])
[/if]
}
[/let]
[/template]

[template private generateGetListTestImplementation(aStructuralFeature : EStructuralFeature,aClass : EClass)]
[let varName : String = aStructuralFeature.getVariableName() ]
func Test[aClass.name.toUpperFirst()/][aStructuralFeature.name.toUpperFirst()/]GetList(t *testing.T) {
	obj := [aClass.getConstructorName()/]()
	[if aStructuralFeature.eType.name = 'EFeatureMapEntry' or aStructuralFeature.volatile]
	assert.Nil(t, obj.[aStructuralFeature.getGetterName()/]())
	[else]
	assert.NotNil(t, obj.[aStructuralFeature.getGetterName()/]())
	[/if]
}
[/let]
[/template]

[template private generateEGetTestImplementation(aClass : EClass)]
[let features : Collection(EStructuralFeature) = aClass.getEGetFeatures()]
[if features->notEmpty()]
func Test[aClass.name.toUpperFirst()/]EGet(t *testing.T) {
	obj := [aClass.getConstructorName()/]()
	[for (anStructFeature : EStructuralFeature | features )]
    {
    [let lazy : String = anStructFeature.getLazy()]
		[if anStructFeature.eType.name = 'EFeatureMapEntry' or anStructFeature.volatile]
		_ = obj
		[elseif not anStructFeature.isContainer() and anStructFeature.isVolatile() and not anStructFeature.hasKey('getterBody')]
		assert.Panics(t, func() { obj.EGetFromID([aClass.getQualifiedIDName(anStructFeature)/], false, false) })
		[elseif not anStructFeature.isContainer() and not anStructFeature.isVolatile() and lazy <> 'no' and lazy = 'action']
		_ = obj
		[else]
		assert.Equal(t, obj.[anStructFeature.getGetterName()/](), obj.EGetFromID([aClass.getQualifiedIDName(anStructFeature)/], false, false))
		[/if]
	[/let]
	}
    [/for]
}
[/if]
[/let]
[/template]

[template private generateEInvokeTestImplementation(aClass : EClass)]
[let operations : Collection(EOperation) = aClass.getEInvokeOperations()]
[if operations->notEmpty()]
func Test[aClass.name.toUpperFirst()/]EInvoke(t *testing.T) {
	obj := [aClass.getConstructorName()/]()
    [for ( eOperation : EOperation | operations )]
    {
		assert.Panics(t, func() { obj.EInvokeFromID([eOperation.eContainingClass.getOperationIDName(eOperation)/], nil) })
	}
    [/for]
}
[/if]
[/let]
[/template]

[template private generateEIsSetTestImplementation(aClass : EClass)]
[let features : Collection(EStructuralFeature) = aClass.getEIsSetFeatures()]
[if features->notEmpty()]
func Test[aClass.name.toUpperFirst()/]EIsSet(t *testing.T) {
	obj := [aClass.getConstructorName()/]()
	[for (anStructFeature : EStructuralFeature | features)]
	{
		[if anStructFeature.eType.name = 'EFeatureMapEntry' or anStructFeature.volatile]
		_ = obj
		[elseif anStructFeature.isListType()]
		    [if anStructFeature.isField()]
		assert.Equal(t, obj.[anStructFeature.name/] != nil && obj.[anStructFeature.name/].Size() != 0, obj.EIsSetFromID([aClass.getQualifiedIDName(anStructFeature)/]))
		    [else]
		assert.Equal(t, obj.[anStructFeature.getGetterName()/]().Size() != 0, obj.EIsSetFromID([aClass.getQualifiedIDName(anStructFeature)/]))
		    [/if]
		[else]
		    [let accessor : String = if isField() then anStructFeature.getVariableName() else anStructFeature.getGetterName()+'()' endif]
		    [if eType.oclIsKindOf(EEnum)]
		assert.Equal(t, obj.[accessor/] != [anStructFeature.oclAsType(EAttribute).generateDefaultValue()/], obj.EIsSetFromID([aClass.getQualifiedIDName(anStructFeature)/]))
		    [else]
		_ = obj
		    [/if]
		    [/let]
		[/if]
	}
	[/for]
}
[/if]
[/let]
[/template]

[template private generateEUnSetTestImplementation(aClass : EClass)]
[let features : Collection(EStructuralFeature) = aClass.getEUnSetFeatures()]
[if features->notEmpty()]
func Test[aClass.name.toUpperFirst()/]EUnset(t *testing.T) {
	obj := [aClass.getConstructorName()/]()
    [for (anStructFeature : EStructuralFeature | features)]
	{
    [if anStructFeature.eType.name = 'EFeatureMapEntry' or anStructFeature.volatile]
		_ = obj
	[elseif anStructFeature.isListType() and not anStructFeature.isUnSettable()]
		obj.EUnsetFromID([aClass.getQualifiedIDName(anStructFeature)/])
        assert.Equal(t, 0, obj.[anStructFeature.getGetterName()/]().Size())
	[else]
		_ = obj
    [/if]
	}
	[/for]
}
[/if]
[/let]
[/template]

[template private generateESetTestImplementation(aClass : EClass)]
[let features : Collection(EStructuralFeature) = aClass.getESetFeatures()]
[if features->notEmpty()]
func Test[aClass.name.toUpperFirst()/]ESet(t *testing.T) {
	obj := [aClass.getConstructorName()/]()
    [for (anStructFeature : EStructuralFeature | features)]
	{
	[if anStructFeature.eType.name = 'EFeatureMapEntry' or anStructFeature.volatile]
		_ = obj
	[elseif anStructFeature.isListType()]
		l := NewImmutableEList(['['/][']'/]interface{}{})
		obj.ESetFromID([aClass.getQualifiedIDName(anStructFeature)/], l)
		assert.Equal(t, 0, obj.[anStructFeature.getGetterName()/]().Size())
		// assert.Equal(t, elem, obj.[anStructFeature.getGetterName()/]().Get(0))
	[else]
		_ = obj
    [/if]
	}
	[/for]
}
[/if]
[/let]
[/template]

[template private generateEInverseAddTestImplementation(aClass : EClass)]
[let features : OrderedSet(EStructuralFeature) = aClass.getEInverseAddFeatures()]
[if features->notEmpty()]
func Test[aClass.name.toUpperFirst()/]EInverseAdd(t *testing.T) {
	[for ( aFeature : EStructuralFeature | features )]
	{
		[if aFeature.eType.name = 'EFeatureMapEntry' or aFeature.volatile]
		_ = obj
		[elseif aFeature.isListType()]
		obj := [aClass.getConstructorName()/]()
		obj.EBasicInverseAdd(&[if not aClass.ePackage.isEcorePackage()]ecore.[/if]MockEObject{}, [aClass.getQualifiedIDName(aFeature)/], &[if not aClass.ePackage.isEcorePackage()]ecore.[/if]MockENotificationChain{})
		assert.Equal(t, 1, obj.[aFeature.getGetterName()/]().Size())
		[/if]
	}
	[/for]
}
[/if]
[/let]
[/template]

[template private generateEInverseRemoveTestImplementation(aClass : EClass)]
[let features : OrderedSet(EStructuralFeature) = aClass.getEInverseRemoveFeatures()->sortedBy(name)]
[if features->notEmpty()]
func Test[aClass.name.toUpperFirst()/]EInverseRemove(t *testing.T) {
	[for ( aFeature : EStructuralFeature | features )]
	{
		[if aFeature.eType.name = 'EFeatureMapEntry' or aFeature.volatile]
		_ = obj
		[elseif aFeature.isListType()]
		obj := [aClass.getConstructorName()/]()
		mock := &[if not aClass.ePackage.isEcorePackage()]ecore.[/if]MockEObject{}
		obj.[aFeature.getGetterName()/]().Add(mock)
		obj.EBasicInverseRemove(mock, [aClass.getQualifiedIDName(aFeature)/], &[if not aClass.ePackage.isEcorePackage()]ecore.[/if]MockENotificationChain{})
		assert.Equal(t, 0, obj.[aFeature.getGetterName()/]().Size())
		[/if]
	}
	[/for]
}
[/if]
[/let]
[/template]
