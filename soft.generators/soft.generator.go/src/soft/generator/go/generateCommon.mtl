[**
 * This file is part of soft.generator.go, a project for go code 
 * generation of an ecore model
 *
 * Copyright(c) 2021 MASA Group
 *	
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
**/]

[comment encoding = UTF-8 /]
[module generateCommon('http://www.eclipse.org/emf/2002/Ecore')/]

[import soft::generator::common::generateCommon/]
[import soft::generator::common::generateUtils/]


[**
 * package property
*/]
[query public hasPackageProperty(anPackage : EPackage, aProperty : String ) : Boolean =
	let property : OclAny = getProperty(aProperty) in 
	if property.oclIsUndefined() or property = '' then
		anPackage.hasKey(aProperty)
	else
		true
	endif
/]

[query public getPackageProperty(anPackage : EPackage, aProperty : String ) : String =
	let property : OclAny = getProperty(aProperty) in 
	if property.oclIsUndefined() or property = '' then
		anPackage.valueKey(aProperty)
	else
		property
	endif
/]

[**
 * Version
*/]
[query public getGoVersion(aPackage : EPackage) : String = if aPackage.hasPackageProperty('goVersion') then aPackage.getPackageProperty('goVersion') else '1.19' endif/]

[query public compareVersion(aAny : OclAny, v1 : String, v2 : String) : Integer =
	let v1Tokenized : Sequence(String) = v1.tokenize('.') in
    let v2Tokenized : Sequence(String) = v2.tokenize('.') in
	let v1Parts : Sequence(String) = if v1Tokenized->size() >= v2Tokenized->size() then v1Tokenized else v2Tokenized endif in
	let v2Parts : Sequence(String) = if v1Tokenized->size() >= v2Tokenized->size() then v2Tokenized else v1Tokenized endif in
	let order : Integer = if v1Tokenized->size() >= v2Tokenized->size() then 1 else -1 endif in
 	Sequence{1..v1Parts->size()}->iterate( index ; res : Integer = -2 |
        if res = -2 then
			if index > v2Parts->size() then
            	order 
        	else
				let p1 : String = v1Parts->at(index) in
	        	let p2 : String = v2Parts->at(index) in
				let c : Integer = p1.strcmp(p2) in
				if c <> 0 then
					order*c
				else
					if index = v1Parts->size() then
						0
					else  
	            		res
					endif
				endif
			endif
		else
			res
        endif
	)
/]

[**
 * Returns true if ecore module is the default one
*/]
[query public isDefaultEcoreModule(aPackage : EPackage) : Boolean =
	aPackage.getEcoreModulePath() = 'github.com/masagroup/soft.go/ecore' 
/]

[**
 * Get Ecore module default path
*/]
[query public getDefaultEcoreModulePath(aPackage : EPackage) : String = 'github.com/masagroup/soft.go/ecore' /]

[**
 * Get Ecore module default namespace
*/]
[query public getDefaultEcoreModuleNamespace(aPackage : EPackage) : String = 'ecore' /]

[**
 * Get Ecore module path
*/]
[query public getEcoreModulePath(aPackage : EPackage) : String =
	 if aPackage.hasPackageProperty('ecoreModule') then 
		let p : String = aPackage.getPackageProperty('ecoreModule') in
		let index : Integer = p.index('=') in 
        if index = -1 then
			p
		else
            p.substring(index+1) 
        endif
	else 
		aPackage.getDefaultEcoreModulePath()
	endif
/]

[**
 * Get Ecore module namespace
*/]
[query public getEcoreModuleNamespace(aPackage : EPackage) : String =
	if aPackage.hasPackageProperty('ecoreModule') then
		let p : String = aPackage.getPackageProperty('ecoreModule') in
		let index : Integer = p.index('=') in 
        if index = -1 then
			let namespaceIndex : Integer = p.lastIndexOf('/') in
			if namespaceIndex = -1 then
				''
			else
				p.substring(namespaceIndex+1)
			endif
		else
            p.substring(1,index-1)
        endif
	else 
		aPackage.getDefaultEcoreModuleNamespace()
	endif
/]

[**
 * File Comments 
*/]
[template public fileComment(aAny : OclAny)]
// Code generated by soft.generator.go. DO NOT EDIT.

[getFileNotes()/]
[/template]

[query public hasExtension( aModelElement : EModelElement ) : Boolean = hasKey('extension') and valueKey('extension' )='true'/]
[query public isExported( aNamedElement : ENamedElement ) : Boolean = 
	if aNamedElement.oclIsKindOf(EPackage) then aNamedElement.oclAsType(EPackage).isExported()
	else if aNamedElement.oclIsKindOf(EClassifier) then aNamedElement.oclAsType(EClassifier).isExported()
	else false
	endif endif
/]

[query public isExported( aPackage : EPackage ) : Boolean = 
	if aPackage.hasPackageProperty('exported') then 
		aPackage.getPackageProperty('exported') = 'true' 
	else 
		false 
	endif
/]
[query public isExported( aClassifier : EClassifier ) : Boolean = 
	if aClassifier.hasKey('exported') then 
		aClassifier.valueKey('exported') = 'true' 
	else 
		aClassifier.ePackage.isExported() 
	endif
/]

[**
 * Factory / Package / Classes Interfaces and Implementations Names  
*/]
[** search for an annotation in an element and in its ancestors if not present. **/]
[query private getAncestor( aElement : EModelElement ) : EModelElement = 
if aElement.oclIsKindOf(EOperation) then aElement.oclAsType(EOperation).eContainingClass
else if aElement.oclIsKindOf(EStructuralFeature) then aElement.oclAsType(EStructuralFeature).eContainingClass
else if aElement.oclIsKindOf(EClass) then aElement.oclAsType(EClass).ePackage
else null
endif endif endif 
/]

[query private getAncestors( aElement : EModelElement ) : Sequence(EModelElement) = 
    let ancestor : EModelElement = aElement.getAncestor() in
    if ( ancestor.oclIsUndefined() ) then
        Sequence(EModelElement){}
    else
        ancestor.getAncestors()->prepend( ancestor )
    endif
/]

[query private getAnnotationValue(aElement : EModelElement, aKey:String ) : String =
    if aElement.hasKey(aKey) then
        aElement.valueKey( aKey )
    else
        let ancestor : EModelElement = aElement.getAncestor() in
        if ancestor.oclIsUndefined() then
            null
        else
            ancestor.getAnnotationValue(aKey)
        endif
    endif     
/]
[** Retrieve a key in an element and its ancestors and then regexp replace the value with the default rule**/]
[query private getElementName( aElement : ENamedElement, aKey:String ) : String = aElement.getElementName(aElement.name, aKey, null)/]
[query private getElementName( aElement : ENamedElement, aName : String , aKey:String ) : String = aElement.getElementName(aName, aKey, null)/]
[query private getElementName( aElement : ENamedElement, aName : String , aKey:String , defaultRule : String ) : String =
    let value : String = aElement.getAnnotationValue( aKey ) in
    let rule : String = if value.oclIsUndefined() then defaultRule else value endif in
    if rule.oclIsUndefined() then
        aName
    else
        let index : Integer = rule.index( ':' ) in
        let pattern : String = if index = -1 then '(.*)' else rule.substring(1, index - 1) endif in
        let replacement : String = if index = -1 then rule else rule.substring(index + 1) endif in
        aName.replaceFirst( pattern , replacement )
    endif
/]

[** Factory Names **/]
[query public getFactoryName( aPackage : EPackage ) : String = aPackage.getElementName(aPackage.name, 'factoryName','$1Factory').toUpperFirst()/]
[query public getFactoryImplementationName( aPackage : EPackage ) : String = aPackage.getImplementationName( getFactoryName() )/]
[query public getFactoryInternalName( aPackage : EPackage ) : String = aPackage.name + 'FactoryInternal'/]
[query public getFactoryExtensionName( aPackage : EPackage ) : String = aPackage.getExtensionName( aPackage.getFactoryName() )/]

[** Package Names **/]
[query public getPackageName( aPackage : EPackage ) : String = aPackage.getElementName(aPackage.name, 'packageName','$1Package').toUpperFirst()/]

[** Interface Names **/]
[query public getInterfaceName( aClass : EClass ) : String = aClass.getInterfaceName(aClass.name)/]
[query public getInterfaceName( aPackage : EPackage ) : String = aPackage.getInterfaceName( getPackageName() )/]
[query private getInterfaceName( aNamedElement : ENamedElement , aName : String ) : String = aNamedElement.getElementName( aName, 'interfaceName').toUpperFirst() /]

[query public getQualifiedInterfaceName( aClass : EClass ) : String = aClass.ePackage.name + '.'  + aClass.getInterfaceName()/]
[query public getQualifiedInterfaceName( aPackage : EPackage ) : String = aPackage.name + '.' + aPackage.getInterfaceName()/]

[** Implementation Names **/]
[query public getImplementationName( aClass : EClass ) : String = aClass.getImplementationName( aClass.name )/]
[query public getImplementationName( aPackage : EPackage ) : String = aPackage.getImplementationName( getPackageName() ) /]
[query private getImplementationName( aNamedElement : ENamedElement , aName : String ) : String = 
    let name : String = aNamedElement.getElementName( aName, 'implementationName', '$1Impl') in
    if  aNamedElement.isExported() then name.toUpperFirst()
    else name.toLowerFirst() endif/]

[query public getQualifiedImplementationName( aClass : EClass ) : String = aClass.ePackage.name + '.' + aClass.getImplementationName()/]

[** Extension Names **/]
[query public getExtensionName( aClass : EClass ) : String = aClass.getExtensionName(aClass.name )/]
[query public getExtensionName( aPackage : EPackage ) : String = aPackage.getExtensionName( getPackageName() )/]
[query private getExtensionName( aNamedElement : ENamedElement , aName : String ) : String = 
    let name : String = aNamedElement.getElementName( aName, 'extensionName', '$1Ext') in
    if  aNamedElement.isExported() then name.toUpperFirst()
    else name.toLowerFirst() endif/]

[** Mock Names **/]
[query public getMockName( aClass : EClass ) : String = aClass.getMockName(aClass.name )/]
[query private getMockName( aNamedElement : ENamedElement , aName : String ) : String = aNamedElement.getElementName( aName, 'mockName', 'Mock$1')/]
[query public getQualifiedMockName( aClass : EClass ) : String = aClass.ePackage.name + '.'  + aClass.getMockName()/]


[query public getQualifiedExtensionName( aClass : EClass ) : String = aClass.ePackage.name + '.' + aClass.getExtensionName()/]

[** FileNames **/]
[query public getInterfaceFileName( aNamedElement : ENamedElement , aName : String ) : String = aNamedElement.getElementName( aName, 'interfaceFileName', '$1.go').toLower()/]
[query public getImplementationFileName( aNamedElement : ENamedElement , aName : String ) : String = aNamedElement.getElementName( aName, 'implementationFileName', '$1_impl.go').toLower()/]
[query public getMockFileName( aNamedElement : ENamedElement , aName : String ) : String = aNamedElement.getElementName( aName, 'mockFileName', '$1_mock.go').toLower()/]
[query public getMockTestFileName( aNamedElement : ENamedElement , aName : String ) : String = aNamedElement.getElementName( aName, 'mockTestFileName', '$1_mock_test.go').toLower()/]
[query public getImplementationTestFileName( aNamedElement : ENamedElement , aName : String ) : String = aNamedElement.getElementName( aName, 'implementationTestFileName', '$1_impl_test.go').toLower()/]
[query public getFactoryTestFileName( aNamedElement : ENamedElement, packageName : String ) : String = aNamedElement.getElementName( packageName + 'factory', 'factoryTestFileName', '$1_impl_test.go').toLower()/]
[query public getPackageTestFileName( aNamedElement : ENamedElement, packageName : String ) : String = aNamedElement.getElementName( packageName + 'package', 'packageTestFileName', '$1_impl_test.go').toLower()/]

[query public getElementInstanceName(anENamedElement : ENamedElement) : String = anENamedElement.getMemberName()/]

[query private getElementTypeName(anENamedElement : ENamedElement) : String =
if anENamedElement.oclIsTypeOf(EClass) then 'Class'
else if anENamedElement.oclIsTypeOf(EAttribute) then 'Attribute'
else if ( anENamedElement.oclIsTypeOf(EOperation) ) then 'Operation'
else if ( anENamedElement.oclIsTypeOf(EReference) ) then 'Reference'
else ''
endif endif endif endif
/]

[query public getReflectiveGetterName(anENamedElement : ENamedElement) : String = 
let getterName : String = 'get' + anENamedElement.getElementAccessorName() in
let ecorePackageClass : EClass = anENamedElement.eClass().ePackage.eClass() in
let methodName : String = if ecorePackageClass.eAllOperations->exists( name = getterName ) then getterName + anENamedElement.getElementTypeName() else getterName endif in
methodName.toUpperFirst()
/]

[** Accessors Names **/]
[query public getterPrefix(feature : EStructuralFeature) : String = if feature.eType.name = 'EBoolean' then 'Is' else 'Get' endif/]
[query private getAccessorName(feature : EStructuralFeature) : String =
	if feature.eContainingClass.isMapEntry() then
		'Typed' + name.toUpperFirst()
	else
		name.toUpperFirst()
	endif
/]
[query public getSetterName(feature : EStructuralFeature) : String   = feature.getElementName( feature.getAccessorName() , 'setterName', 'Set$1')/]
[query public getGetterName(feature : EStructuralFeature) : String   = feature.getElementName( feature.getAccessorName(), 'getterName', feature.getterPrefix() + '$1')/]
[query public getUnSetterName(feature : EStructuralFeature) : String = feature.getElementName( feature.getAccessorName(), 'unSetterName', 'Unset$1')/]
[query public getIsSetName(feature : EStructuralFeature) : String    = feature.getElementName( feature.getAccessorName(), 'isSetName', 'IsSet$1')/]

[query public getOperationName(aOperation : EOperation ) : String = aOperation.getElementName( aOperation.name , 'operationName' ).toUpperFirst()/]

[query public getMetaType(aPackage : EPackage , anENamedElement : ENamedElement) : String = getShortQualifiedName( anENamedElement.eClass().getQualifiedInterfaceName(), aPackage.name ) /]

[** Name Qualification **]
[query public getShortQualifiedName( aQualifiedName : String , aNamespaceName : String ) : String =
    aQualifiedName.getShortQualifiedNameSep(aNamespaceName, '.')
/]

[query public getUnQualifiedName( aQualifiedName : String ) : String =
    aQualifiedName.getUnQualifiedNameSep('.')
/]

[query public getQualification( any : OclAny , aQualifiedName : String ) : String =
    any.getQualificationSep(aQualifiedName, '.') 
/]

[query public getQualifiedIDName( aClass : EClass, aStructuralFeature : EStructuralFeature ) : String =
    aClass.getFeatureIDName( aStructuralFeature )
/]

[query public getQualifiedIDName( aClass : EClass, aOperation : EOperation ) : String =
    aClass.getOperationIDName( aOperation )
/]

[query public isConstantsQualified( aEEnum  : EEnum ) : Boolean = 
	let aPackage : EPackage = aEEnum.ePackage in
	let aEnumNames : OrderedSet(String) = aEEnum.eLiterals.name->asOrderedSet() in
	aPackage.eAllContents(EEnum)->exists( e | e <> aEEnum and aEEnum.eLiterals.name->asOrderedSet()->intersection(aEnumNames)->notEmpty() ) 
/]

[query public getConstantsName(eLiteral : EEnumLiteral) : String =
	let eLiteralName : String =  upperCamelToUpperUnderscore(eLiteral.name.toUpperFirst()) in
	if eLiteral.eEnum.isConstantsQualified() then
		let eEnumName : String = upperCamelToUpperUnderscore(eLiteral.eEnum.name.toUpperFirst()) in	 
		eEnumName + '__' + eLiteralName 
	else eLiteralName 
	endif
/]

[query public getValueName(eLiteral : EEnumLiteral) : String = eLiteral.name/]

[query public getReservedKeywords(oclAny : OclAny) : Sequence(String) = 
	Sequence{ 'break' ,'case' ,'chan' ,'const' ,'continue','default' ,'defer' ,'else' ,'fallthrough' ,'for'
			, 'func' ,'go' ,'goto' ,'if' ,'import' ,'interface' ,'map' ,'package' ,'range' ,'return' ,'select' 
			, 'struct' ,'switch' ,'type' ,'var'
	}
/]

