[**
 * This file is part of soft.generator.go, a project for go code 
 * generation of an ecore model
 *
 * Copyright(c) 2021 MASA Group
 *	
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
**/]

[comment encoding = UTF-8 /]
[module generateType('http://www.eclipse.org/emf/2002/Ecore')/]

[import soft::generator::common::generateCommon/]
[import soft::generator::common::generateUtils/]
[import soft::generator::go::generateCommon/]
[import soft::generator::go::generatePath/]

[query public isBackReference(aStructuralFeature:EStructuralFeature) : Boolean = aStructuralFeature.oclIsKindOf(EReference) and aStructuralFeature.oclAsType(EReference).isBackReference()/]
[query public isBackReference(aReference:EReference) : Boolean = aReference.container or isShared()/]
[query private isShared(aReference : EReference) : Boolean = if (aReference.hasKey('aggregation')) then aReference.valueKey('aggregation')='shared' else false endif/]

[query public getAnyType(aPackage : EPackage) : String =
if compareVersion(aPackage.getGoVersion() , '1.18') >= 0 then
'any'
else
'interface{}'
endif
/]

[query public isAnyType(aPackage : EPackage, type : String) : Boolean =
let anyType : String = aPackage.getAnyType() in
anyType = type
/]

[query private getQualifiedIdentifier( qualification : String, identifier : String ) : String = qualification + '.' + identifier/] 

[query public getQualifiedInterfaceIdentifier( aPackage : EPackage, identifier : String ) : String = getQualifiedIdentifier(aPackage.getInterfacePackagePath(),identifier)/]

[query public getQualifiedInterfaceIdentifier( aClass : EClass ) : String = aClass.ePackage.getQualifiedInterfaceIdentifier( aClass.getInterfaceName() ) /]

[query public getQualifiedInterfaceIdentifier( aEnum : EEnum ) : String = aEnum.ePackage.getQualifiedInterfaceIdentifier( aEnum.name ) /]

[query public getQualifiedImplementationIdentifier( aPackage : EPackage,identifier : String ) : String = getQualifiedIdentifier(aPackage.getImplementationPackagePath(),identifier)/]

[query public getQualifiedImplementationIdentifier( aClass : EClass ) : String = aClass.ePackage.getQualifiedImplementationIdentifier( aClass.getImplementationName() ) /]

[query public getQualifiedExtensionIdentifier( aClass : EClass ) : String = aClass.ePackage.getQualifiedImplementationIdentifier( aClass.getExtensionName() ) /]

[query public getQualifiedMockIdentifier( aPackage : EPackage,identifier : String ) : String = getQualifiedIdentifier(aPackage.getMockPackagePath(),identifier)/]

[query public getQualifiedMockIdentifier( aClass : EClass ) : String = aClass.ePackage.getQualifiedMockIdentifier( aClass.getMockName() ) /]

[query public getImportedIdentifier( aPackage : EPackage, qualifiedName : String, imports : OclAny ) : String =
	if imports.oclIsUndefined() then
		qualifiedName
	else
		let indexDot : Integer = qualifiedName.lastIndex('.') in
		if indexDot = -1 then
			qualifiedName
		else
			let p : String = qualifiedName.substring(1, indexDot-1) in
			let o : String = qualifiedName.substring(indexDot+1) in
			if p = aPackage.getPackagePath() then
				o 
			else
				let i : OclAny = mapGet(imports,p) in		
				if i.oclIsUndefined() then
					let nameIndex : Integer = p.lastIndex('/') in
					if nameIndex = -1 then
						p + '.' + o
					else
						p.substring(nameIndex+1) + '.' + o
					endif
				else
					if i = '' then
						o
					else
						i.oclAsType(String) + '.' + o
					endif
				endif
			endif
		endif
	endif
/]


[query public getSimpleIdentifier(qualifiedIdentifier : String ) : String = 
	let index : Integer = qualifiedIdentifier.lastIndex('.') in
	if index = -1 then
		qualifiedIdentifier
	else
		qualifiedIdentifier.substring(index+1)
	endif
/]


[query public getIdentifierPackagePath( qualifiedIdentifier : String ) : String =
	let identifier : String =  
		if qualifiedIdentifier.size() > 0 and qualifiedIdentifier.first(1) = '*' then 
			qualifiedIdentifier.substring(2) 
		else 
			qualifiedIdentifier 
		endif in
	let index : Integer = identifier.lastIndex('.') in
	if index = -1 then
		''
	else
		identifier.substring(1,index-1)
	endif
/]


[template public generateType(aElement : ETypedElement, imports : OclAny) post (trim())]
[if aElement.oclIsUndefined() or aElement.eGenericType.oclIsUndefined()]
[else]
    [let aPackage : EPackage = aElement.getEPackage()]
	[let ecore : EPackage = getEcorePackage()]
	[if (aElement.isMapType())]
		[aPackage.getImportedIdentifier( ecore.getQualifiedInterfaceIdentifier('EMap'), imports)/]
	[elseif aElement.isListType()]
		[aPackage.getImportedIdentifier( ecore.getQualifiedInterfaceIdentifier('EList'), imports)/]
    [else]
        [aElement.eGenericType.generateType(aPackage,imports)/]
    [/if]
    [/let]
	[/let]
[/if]
[/template]

[template public generateType(aDataType : EGenericType, aPackage : EPackage, imports : OclAny) post (trim())]
[if (aDataType.oclIsUndefined() or aDataType.eClassifier.oclIsUndefined())]
[else]
[aPackage.getImportedIdentifier( aDataType.eClassifier.getType(), imports)/]
[/if]
[/template]

[template public generateParameterList(aOperation:EOperation, imports : OclAny, names : Boolean ) post(trim())]
[for (sParameter : EParameter | aOperation.eParameters) separator (', ')][if names][sParameter.name/] [/if][sParameter.generateType(imports)/][/for]
[/template]

[template public generateParameterCall(aOperation:EOperation) post(trim())]
[for (sParameter : EParameter | aOperation.eParameters) separator (', ')][sParameter.name/][/for]
[/template]



[comment {ecore types..., go type, default value, test value, comparison operator}/]
[query private getAllDataTypes(aPackage : EPackage) : Sequence( Sequence( String ) ) =
	let ecore : EPackage = getEcorePackage() in
	let anyType : String = aPackage.getAnyType() in 
    Sequence {
        Sequence{ 'java.lang.Boolean', 'boolean', 'bool', 'false' , 'true', ''},
        Sequence{ 'java.lang.Integer', 'int' , '0', '45' , ''},
		Sequence{ 'java.lang.Byte','java.lang.Character', 'char', 'byte' ,'\'\'', '\'a\'', ''},
		Sequence{ 'byte[]','[]byte' , 'nil', 'nil' , ''},
		Sequence{ 'java.util.Date', '*time.Time', 'nil', 'nil' , ''},
		Sequence{ 'java.lang.Double', 'java.math.BigDecimal', 'double', 'float64' , '0.0' , '3.5' , ''},
		Sequence{ 'java.lang.Float' , 'float' , 'float32' , '0.0', '1.2', ''},
		Sequence{ 'java.lang.Class' , 'reflect.Type', 'nil', 'reflect.TypeOf("")', ''},
		Sequence{ 'java.lang.Object', anyType, 'nil', 'nil', ''},
		Sequence{ 'java.lang.Long' , 'java.math.BigInteger', 'long' , 'int64' , '0', '45' , ''},
        Sequence{ 'java.util.Map' , ecore.getQualifiedInterfaceIdentifier('EMap'), 'nil', 'nil' , ''},
        Sequence{ 'java.util.Map$Entry' , ecore.getQualifiedInterfaceIdentifier('EMapEntry'), 'nil' , 'nil', ''},
		Sequence{ 'java.lang.Short' , 'short' , 'int16' , '0', '2' , ''},
        Sequence{ 'java.lang.String' , 'string', '""' , '"Test String"', ''},
		Sequence{ 'java.lang.Error' , 'error', 'nil' , 'errors.New("Error")', ''},

		Sequence{ 'com.google.common.primitives.UnsignedLong' , 'uint64', '0' , '1', ''},

		Sequence{ 'org.eclipse.emf.common.util.DiagnosticChain', ecore.getQualifiedInterfaceIdentifier('EDiagnosticChain'), 'nil', 'nil', '' },
		Sequence{ 'org.eclipse.emf.common.util.EList', ecore.getQualifiedInterfaceIdentifier('EList'), 'nil', 'ecore.NewEmptyBasicEList()', '' },
		Sequence{ 'org.eclipse.emf.common.util.Enumerator', anyType, 'nil', 'nil', ''},		        
		Sequence{ 'org.eclipse.emf.ecore.util.FeatureMap', anyType, 'nil', 'nil', ''},
        Sequence{ 'org.eclipse.emf.ecore.util.FeatureMap$Entry', anyType, 'nil', 'nil', ''},
        Sequence{ 'org.eclipse.emf.ecore.resource.Resource', ecore.getQualifiedInterfaceIdentifier('EResource'), 'nil' , 'nil', '' },
        Sequence{ 'org.eclipse.emf.ecore.resource.ResourceSet', ecore.getQualifiedInterfaceIdentifier('EResourceSet'), 'nil' , 'nil', '' },
		Sequence{ 'org.eclipse.emf.common.util.TreeIterator', ecore.getQualifiedInterfaceIdentifier('EIterator'), 'nil' , 'nil', '' }
    }
/]


[query public getInstanceTypeName( aClassifier : EClassifier ) : String =
	let instanceTypeName : String = 
	if hasKey(aClassifier, 'instanceTypeName') then
		aClassifier.valueKey('instanceTypeName')
	else if not aClassifier.instanceTypeName.oclIsUndefined() then
		aClassifier.instanceTypeName
	else if aClassifier.oclIsKindOf(EClass) then
		aClassifier.oclAsType(EClass).getQualifiedInterfaceIdentifier()
	else
		''
	endif endif endif in
	let aPackage : EPackage = aClassifier.ePackage in
	let goTypeName : String = aPackage.getAllDataTypes()->iterate( s ; res : String = '' |
    if res = '' then
        if s->exists(n : String | n = instanceTypeName) then
            s->at( s->size() - 3 )
        else
            res
        endif
    else 
        res 
    endif
	) in
	if goTypeName = '' then
		instanceTypeName
	else
		goTypeName
	endif
/] 

[query public getUndecoratedTestValue(aClassifier : EClassifier,aPackage : EPackage, imports : OclAny) : String =
	if aClassifier.oclIsUndefined() then 'nil'
    else if aClassifier.oclIsKindOf( EClass ) then aClassifier.oclAsType(EClass).getTestValue(aPackage,imports)
    else if aClassifier.oclIsKindOf( EEnum ) then aClassifier.oclAsType(EEnum).getTestValue(aPackage,imports)
    else if aClassifier.oclIsKindOf( EDataType ) then aClassifier.oclAsType(EDataType).getTestValue(aPackage,imports)
	else '' endif endif endif endif	
/]

[query public getTestValue(aClassifier : EClassifier,aPackage : EPackage, imports : OclAny) : String =
	if aClassifier.oclIsUndefined() then 'nil'
    else if aClassifier.oclIsKindOf( EClass ) then aClassifier.oclAsType(EClass).getTestValue(aPackage,imports)
    else if aClassifier.oclIsKindOf( EEnum ) then aClassifier.oclAsType(EEnum).getTestValue(aPackage,imports)
    else if aClassifier.oclIsKindOf( EDataType ) then 
		let t : String = aClassifier.getType() in
		let v : String = aClassifier.oclAsType(EDataType).getTestValue(aPackage,imports) in
		let isPtr : Boolean = t.size() > 0 and t.first(1) = '*' in
		(if isPtr then '(' else '' endif) + aPackage.getImportedIdentifier( aClassifier.getType(), imports)  + (if isPtr then ')' else '' endif) + '(' + aPackage.getImportedIdentifier( v, imports) + ')'
    else '' endif endif endif endif	
/]

[query private getTestValue( aClass : EClass ,aPackage : EPackage , imports : OclAny) : String =
	let ecore : EPackage = getEcorePackage() in 
	let qualifiedMockConstructorName : String = if aClass.name='EObject' then ecore.getQualifiedInterfaceIdentifier('NewMockEObjectInternal') else aClass.ePackage.getQualifiedInterfaceIdentifier('New' + aClass.getMockName()) endif in 
	aPackage.getImportedIdentifier( qualifiedMockConstructorName, imports)+'(t)'
/]

[query private getTestValue( aEnum : EEnum ,aPackage : EPackage, imports : OclAny ) : String =
	if aEnum.eLiterals->size() >= 1 then
		let constant : String = aEnum.eLiterals->at(if aEnum.eLiterals->size() > 1 then 2 else 1 endif).getConstantsName() in
		aPackage.getImportedIdentifier( aEnum.ePackage.getQualifiedInterfaceIdentifier(constant), imports)
	else 0 endif/]

[query private getTestValue( aDataType : EDataType ,aPackage : EPackage, imports : OclAny) : String = 
	if hasKey(aDataType, 'testValue') then
		aDataType.valueKey('testValue')
	else
		let typeName : String = aDataType.getInstanceTypeName() in
		if typeName.size() > 0 and typeName.first(1) = '*' then
			'nil'
		else
			aPackage.getAllDataTypes()->iterate( s ; res : String = '' |
		    if res = '' then
		        if s->exists(n : String | n = typeName) then
					aPackage.getImportedIdentifier( s->at( s->size() - 1 ), imports)
				else
					res
		        endif
		    else 
		        res 
		    endif
		 	) 
	endif endif
/]

[query public getType( aClassifier : EClassifier ) : String = 
    if aClassifier.oclIsUndefined() then aClassifier.ePackage.getAnyType()
    else if aClassifier.oclIsKindOf( EClass ) then aClassifier.oclAsType(EClass).getType()
    else if aClassifier.oclIsKindOf( EEnum ) then aClassifier.oclAsType(EEnum).getType()
    else if aClassifier.oclIsKindOf( EDataType ) then aClassifier.oclAsType(EDataType).getType()
    else '' endif endif endif endif
/]
[query private getType( aClass : EClass ) : String = aClass.getQualifiedInterfaceIdentifier()/]
[query private getType( aEnum : EEnum ) : String = aEnum.getQualifiedInterfaceIdentifier()/]
[query private getType( aDataType : EDataType ) : String = aDataType.getInstanceTypeName()/]

[query public getDefaultValue(anEAttribute : EAttribute, aContext : EClass, imports : OclAny) : String = anEAttribute.getDefaultValue(aContext.ePackage,imports)/]

[query public getDefaultValue(anEAttribute : EAttribute, aContext : EPackage, imports : OclAny) : String = 
	if anEAttribute.many then 
		'' 
	else 
		if (defaultValueLiteral->notEmpty()) then 
			eType.getDefaultValueFromLiteral(aContext,defaultValueLiteral,imports) 
		else 
			eType.getDefaultValue(aContext, imports) 
		endif 
	endif
/]


[query private getDefaultValueFromLiteral(aClassifier : EClassifier, aContext : EPackage, literal : String , imports : OclAny) : String =
	 if aClassifier.oclIsKindOf( EEnum ) then aClassifier.oclAsType(EEnum).getDefaultValueFromLiteral(aContext,literal,imports)
	 else if aClassifier.oclIsKindOf( EDataType ) then aClassifier.oclAsType(EDataType).getDefaultValueFromLiteral(aContext,literal,imports)
	 else literal endif endif
/]

[query private getDefaultValueFromLiteral(aEnum : EEnum, aContext : EPackage, literal : String , imports : OclAny) : String =
	let eLiterals : OrderedSet(EEnumLiteral) = aEnum.eLiterals->select( el : EEnumLiteral | el.name = literal ) in
	if eLiterals->isEmpty() then
		literal 
	else
		aContext.getImportedIdentifier( aEnum.ePackage.getQualifiedInterfaceIdentifier(eLiterals->first().getConstantsName()), imports)
	endif
/]

[query private getDefaultValueFromLiteral(aDataType : EDataType, aContext : EPackage, literal : String , imports : OclAny) : String = 
	literal
/]

[query public getDefaultValue(aClassifier : EClassifier, aContext : EClass, imports : OclAny) : String = aClassifier.getDefaultValue(aContext.ePackage,imports)/]

[query public getDefaultValue(aClassifier : EClassifier, aContext : EPackage, imports : OclAny) : String =
    if aClassifier.oclIsKindOf( EEnum ) then aClassifier.oclAsType(EEnum).getDefaultValue(aContext,imports)
    else if aClassifier.oclIsKindOf( EDataType ) then aClassifier.oclAsType(EDataType).getDefaultValue(aContext,imports)
    else 'nil' endif endif
/]

[query public getDefaultValue(aEnum : EEnum, aContext : EClass, imports : OclAny) : String = aEnum.getDefaultValue(aContext.ePackage,imports)/]

[query public getDefaultValue(aEnum : EEnum, aContext : EPackage, imports : OclAny) : String = 
	if aEnum.eLiterals->notEmpty() then
		aContext.getImportedIdentifier( aEnum.ePackage.getQualifiedInterfaceIdentifier(aEnum.eLiterals->at(1).getConstantsName()), imports) 
	else 
		0 
	endif
/]

[query public getDefaultValue(aDataType : EDataType, aContext : EClass, imports : OclAny) : String = aDataType.getDefaultValue(aContext.ePackage,imports)/]

[query public getDefaultValue(aDataType : EDataType, aContext : EPackage, imports : OclAny) : String =
	if hasKey(aDataType, 'defaultValue') then
		aDataType.valueKey('defaultValue')
	else if aDataType.name <> 'EChar' and not aDataType.defaultValue.oclIsUndefined() then
		aDataType.defaultValue.toString()
	else
		let typeName : String = aDataType.getInstanceTypeName() in
		if typeName.size() > 0 and typeName.first(1) = '*' then
			'nil'
		else
		    aContext.getAllDataTypes()->iterate( s ; res : String = '' |
		    if res = '' then
		        if s->exists(n : String | n = typeName) then
					aContext.getImportedIdentifier( s->at( s->size() - 2 ), imports)
		        else
		            res
		        endif
		    else 
		        res 
		    endif	
	 		)
	endif endif endif
/]

[query public getDefaultValueWithType(aFeature : EStructuralFeature, aContext : EClass , imports : OclAny) : String = aFeature.getDefaultValueWithType(aContext.ePackage,imports)/]

[query public getDefaultValueWithType(aFeature : EStructuralFeature, aContext : EPackage , imports : OclAny) : String =
	if aFeature.oclIsKindOf(EAttribute) then
		let defaultValue : String = aFeature.oclAsType(EAttribute).getDefaultValue(aContext,imports) in
		if defaultValue = '' then ''
		else if defaultValue = 'nil' then 'nil'
		else
			let t : String = aFeature.eType.getType() in
			let isPtr : Boolean = t.size() > 0 and t.first(1) = '*' in
			(if isPtr then '(' else '' endif) + aContext.getImportedIdentifier( aFeature.eType.getType(), imports) +(if isPtr then ')' else '' endif) + '(' + defaultValue + ')'
		endif endif
	else
		'nil'
	endif
/]



[query public getComparisonFunction( aDataType : EDataType) : String =
	let typeName : String = aDataType.getInstanceTypeName() in 
	aDataType.ePackage.getAllDataTypes()->iterate( s ; res : String = '' |
    if res = '' then
        if s->exists(n : String | n = typeName) then
            s->at( s->size() )
        else
            res
        endif
    else 
        res 
    endif
	)
/]

[template public generateImports(imports : OclAny, packagePath : String)]
[if not imports.oclIsUndefined()]
[for (path : OclAny | imports.mapKeys()->sortedBy(oclAsType(String)))]
[if path <> packagePath]
[let name : OclAny = imports.mapGet(path)]
import [if not name.oclIsUndefined()][name.oclAsType(String)/][/if] "[path.oclAsType(String)/]" 
[/let]
[/if]
[/for]
[/if]
[/template]

