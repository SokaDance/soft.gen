[comment encoding = UTF-8 /]
[module generateReflectives('http://www.eclipse.org/emf/2002/Ecore')/]

[import soft::generator::common::generateCommon/]
[import soft::generator::common::generateElement/]
[import soft::generator::common::generateReflectives/]
[import soft::generator::ts::generateCommon/]
[import soft::generator::ts::generateType/]
[import soft::generator::ts::lib::generateCommon/]

[template public generateReflectivesDefinition(aClass : EClass)]
[if aClass.hasElementID() or
	aClass.getEGetFeatures()->notEmpty() or
    aClass.getESetFeatures()->notEmpty() or
    aClass.getEUnSetFeatures()->notEmpty() or
    aClass.getEIsSetFeatures()->notEmpty() or
    aClass.getEInvokeOperations()->notEmpty() or
    aClass.getEInverseAddFeatures()->notEmpty() or
    aClass.getEInverseRemoveFeatures()->notEmpty()]
[if aClass.hasElementID()]
[aClass.generateElementIDDefinition()/]

[/if]
[if aClass.getEGetFeatures()->notEmpty()]
[aClass.generateEGetDefinition()/]

[/if]
[if aClass.getESetFeatures()->notEmpty()]
[aClass.generateESetDefinition()/]

[/if]
[if aClass.getEUnSetFeatures()->notEmpty()]
[aClass.generateEUnSetDefinition()/]

[/if]
[if aClass.getEIsSetFeatures()->notEmpty()]
[aClass.generateEIsSetDefinition()/]

[/if]
[if aClass.getEInvokeOperations()->notEmpty()]
[aClass.generateEInvokeDefinition()/]

[/if]
[if aClass.getEInverseAddFeatures()->notEmpty()]
[aClass.generateEInverseAddDefinition()/]

[/if]
[if aClass.getEInverseRemoveFeatures()->notEmpty()]
[aClass.generateEInverseRemoveDefinition()/]
[/if]
[/if]
[/template]

[template private generateElementIDDefinition(aClass : EClass)]
[let aPackage : EPackage = aClass.ePackage]
[let mixinClasses : Set(EClass) = aClass.getMixinClasses()]
[if mixinClasses->exists( c : EClass | c.getImplementedFeatures()->notEmpty())] 
eDerivedFeatureID(eContainer : EObject, featureID number) : number {
	let eClass = eContainer as EClass;
[for (aMixinClass : EClass | mixinClasses)]
    if (eClass == GetPackage().Get[aMixinClass.getElementAccessorName()/]()) {
        switch featureID {
[for (aFeature : EStructuralFeature | aMixinClass.getImplementedFeatures() )]
            case [aMixinClass.getQualifiedIDName(aFeature)/] : return [aClass.getQualifiedIDName(aFeature)/]
[/for]
            default: return -1
        }
    }
[/for]  
    return super.eDerivedFeatureID(eContainer, featureID);
}
[/if]

[if mixinClasses->exists( c : EClass | c.getImplementedOperations()->notEmpty())]
eDerivedOperationID(eContainer : EObject, operationID number) number {
	let eClass = eContainer as EClass;
[for (aMixinClass : EClass | mixinClasses)]
    if (eClass == GetPackage().Get[aMixinClass.getElementAccessorName()/]()) {
        switch featureID {
[for (aOperation : EOperation | aMixinClass.getImplementedOperations() )]
            case [aMixinClass.getQualifiedIDName(aOperation)/] : return [aClass.getQualifiedIDName(aOperation)/]
[/for]
            default: return -1
        }
    }
[/for]  
    return super.eDerivedOperationID(eContainer, featureID);
}
[/if]
[/let]
[/let]
[/template]

[template private generateEGetDefinition(aClass : EClass)]
eGetFromID(featureID : number , resolve : boolean ) : any {
    switch featureID {
    [for (anStructFeature : EStructuralFeature | aClass.getEGetFeatures()->sortedBy(name))]
    case [aClass.getQualifiedIDName(anStructFeature)/]:
	[if anStructFeature.isProxy()]
		[if anStructFeature.isListType()]
		let list = this.[anStructFeature.name/];
		if !resolve {
			if (isEObjectList(list))
				return list.getUnResolvedList();
		}
		return list;
		[else]
		if resolve {
			return this.[anStructFeature.name/];
		}
		return  this.basicGet[anStructFeature.name.toUpperFirst()/]();
		[/if]		
	[else] 
        return this.[anStructFeature.name/];
	[/if]
    [/for]
    default:
        return super.eGetFromID(featureID, resolve);
    }
}
[/template]


[template private generateEIsSetDefinition(aClass : EClass)]
eIsSetFromID(featureID : number) : boolean {
    switch featureID {
[for (anStructFeature : EStructuralFeature | aClass.getEIsSetFeatures()->sortedBy(name))]
    case [aClass.getQualifiedIDName(anStructFeature)/]:
        return [anStructFeature.generateComparison(aClass)/];
[/for]
    default:
        return super.eIsSetFromID(featureID);
    }
}
[/template]

[template private generateESetDefinition(aClass : EClass)]
eSetFromID(featureID : number, newValue : any) {
    switch featureID {
[for (anStructFeature : EStructuralFeature | aClass.getESetFeatures()->sortedBy(name))]
    case [aClass.getQualifiedIDName(anStructFeature)/]:
    [if anStructFeature.isListType()]
		let list = this.[anStructFeature.name/];
        list.clear()
        list.addAll(newValue as [anStructFeature.generateType()/]));
    [else]
        this.[anStructFeature.name/] = newValue as [anStructFeature.generateType()/];
    [/if]    
[/for]
    default:
        super.eSetFromID(featureID, newValue);
    }
}
[/template]

[template private generateEUnSetDefinition(aClass : EClass)]
eUnsetFromID(featureID : number ) {
    switch featureID {
[for (aStructFeature : EStructuralFeature | aClass.getEUnSetFeatures()->sortedBy(name))]
    case [aClass.getQualifiedIDName(aStructFeature)/]:
    [if aStructFeature.isListType() and not aStructFeature.isUnSettable()]
        this.[aStructFeature.name/]().clear();
    [elseif aStructFeature.isUnSet() ]
        this.[aStructFeature.getUnSetterName()/]();
    [elseif aStructFeature.oclIsKindOf(EReference)]
        this.[aStructFeature.name/] = null;
    [else]
		[let aAttribute : EAttribute = aStructFeature.oclAsType(EAttribute)]
		[let defaultValue : String = aAttribute.getDefaultValue()]
		[if defaultValue <> '']
        this.[aStructFeature.name/] = [defaultValue/];
        [else]
        this.[aStructFeature.name/] = null;
        [/if]
        [/let]
        [/let]
    [/if]
[/for]
    default:
        super.eUnsetFromID(featureID);
    }
}
[/template]

[template private generateEInvokeDefinition(aClass : EClass)]
[let aPackage : EPackage = aClass.ePackage]
eInvokeFromID(operationID : number , arguments : EList<any>) any {
    switch operationID {
    [for ( eOperation : EOperation | aClass.getEInvokeOperations()->sortedBy( getOperationName() ) )]
    case [aClass.getQualifiedIDName(eOperation)/]:
        [if eOperation.isVoid() ]
        this.[eOperation.generateOperationInvoke()/];
        return null;
        [else]
        return this.[eOperation.generateOperationInvoke()/]; 
        [/if]
    [/for]
    default:
        return super.eInvokeFromID(operationID,arguments);
    }
}
[/let]
[/template]

[template private generateOperationInvoke(eOperation : EOperation )]
[eOperation.getOperationName()/]([for (eParameter : EParameter | eOperation.eParameters) separator (',')][let needCast : Boolean = not(not eParameter.oclIsUndefined() and eParameter.upperBound = 1 and not eParameter.eGenericType.oclIsUndefined() and eParameter.eGenericType.eClassifier.isAny())]arguments.Get([i-1/])[if needCast] as [eParameter.generateType()/][/if][/let][/for])
[/template]

[template public generateDefaultValue(anEAttribute : EAttribute) post (trim())]
[if (anEAttribute.eType.oclIsTypeOf(EEnum))]
    [if (anEAttribute.defaultValueLiteral->notEmpty())]
        [anEAttribute.defaultValueLiteral.toUpperCase()/]
    [else]
        [anEAttribute.eType.oclAsType(EEnum).eLiterals->first().name.toUpperCase()/] 
    [/if]
[else]
    [anEAttribute.getDefaultValue()/]
[/if]
[/template]

[template public generateComparison(anStructFeature : EStructuralFeature, aClass : EClass) ? (oclIsKindOf(EAttribute) and not eType.isAny()) post (trim())]
[let aAttribute : EAttribute = anStructFeature.oclAsType(EAttribute)]
[if isListType()]
    [if isField()]
        this.[aAttribute.name/] != null && this.[aAttribute.name/].size() != 0;
    [else]
        this.[aAttribute.name/].size() != 0;
    [/if]
[else]
    [let accessor : String = if isField() then aAttribute.getVariableName() else aAttribute.name endif]
    [if eType.oclIsKindOf(EEnum)]
        this.[accessor/] != [aAttribute.generateDefaultValue()/]
    [else]
		this.[accessor/] != [aAttribute.getDefaultValue()/]
    [/if]
    [/let]
[/if]
[/let]
[/template]

[template public generateComparison(anStructFeature : EStructuralFeature, aClass : EClass) ? (oclIsKindOf(EReference) and not eType.isAny()) post (trim())]
[if isListType()]
    [if isField()]
        this.[anStructFeature.name/] != null && this.[anStructFeature.name/].size() != 0
    [else]
        this.[anStructFeature.name/].size() != 0
    [/if]
[elseif anStructFeature.oclAsType(EReference).isBackReference() ]
    [if anStructFeature.eType.name <> 'EBoolean']
    this.[anStructFeature.name/] != null
    [else]
    this.[anStructFeature.name/]
    [/if]
[else]
    [let accessor : String = if isField() then anStructFeature.getVariableName() else anStructFeature.name endif]
        this.[accessor/] != [anStructFeature.eType.getDefaultValue()/]
    [/let]
[/if]
[/template]

[template public generateComparison(anStructFeature : EStructuralFeature, aClass : EClass) ? (eType.isAny()) post (trim())]
this.[anStructFeature.name/] != ""
[/template]

[template public generateEInverseAddDefinition(aClass : EClass) ]
[let aPackage : EPackage = aClass.ePackage]
eBasicInverseAdd(otherEnd : EObject, featureID : number, notifications : ENotificationChain) : ENotificationChain {
    switch featureID {
[for ( aFeature : EStructuralFeature | aClass.getEInverseAddFeatures()->sortedBy(name) )]
    case [aClass.getQualifiedIDName(aFeature)/]:
    [if aFeature.isListType()]
        let list = this.[aFeature.name/]() as ENotifyingList;
        return list.AddWithNotification(otherEnd, notifications)
    [elseif aFeature.isContainer()]
        let msgs = notifications;
        if (this.eContainer() != null {
            msgs = this.eBasicRemoveFromContainer(msgs);
        }
        [if aFeature.isBasicSet()]
        return this.basicSet[aFeature.name.toUpperFirst()/](otherEnd as [aFeature.generateType()/], msgs);
        [else]
        return this.eBasicSetContainer(otherEnd, [aClass.getQualifiedIDName(aFeature)/], msgs);
        [/if]
    [else]
        [if aFeature.isVolatile() or aFeature.isBackReference()]
        let [aFeature.name/] = [if aFeature.isProxy()]this.basicGet[aFeature.name.toUpperFirst()/]()[else]this.[aFeature.name/][/if];
        [/if]
        let msgs = notifications;
        if ( this.[aFeature.name/] != null ) {
            [if aFeature.isContains()]
            msgs = (this.[aFeature.name/] as EObjectInternal).eInverseRemove(this, EOPPOSITE_FEATURE_BASE - [aClass.getQualifiedIDName(aFeature)/], msgs);
            [else]
                [let reverseFeature : EStructuralFeature = aFeature.oclAsType(EReference).eOpposite]
            msgs = (this.[aFeature.name/] as EObjectInternal).EInverseRemove(this, [reverseFeature.eContainingClass.getQualifiedIDName(reverseFeature)/], msgs);
                [/let]
            [/if]
        }
        return this.basicSet[aFeature.name.toUpperFirst()/](otherEnd.([aFeature.generateType()/]) ,msgs);
    [/if]
[/for]
    default:
        return super.eBasicInverseAdd(otherEnd, featureID, notifications);
    }
}
[/let]
[/template]

[template public generateEInverseRemoveDefinition(aClass : EClass) ? (aClass.getEInverseRemoveFeatures()->notEmpty()) ]
[let aPackage : EPackage = aClass.ePackage]
eBasicInverseRemove(otherEnd : EObject, featureID : number, notifications : ENotificationChain) : ENotificationChain {
    switch featureID {
[for ( aFeature : EStructuralFeature | aClass.getEInverseRemoveFeatures()->sortedBy(name) )]
    case [aClass.getQualifiedIDName(aFeature)/]:
    [if aFeature.isListType()]
        let list = this.[aFeature.name/]() as ENotifyingList;
        return list.removeWithNotification(otherEnd, notifications);
    [elseif aFeature.isContainer() and not aFeature.isBasicSet()]
        return this.eBasicSetContainer(null, [aClass.getQualifiedIDName(aFeature)/], notifications);
    [elseif aFeature.isUnSet()]
        return this.basicUnSet[aFeature.name.toUpperFirst()/](notifications);
    [else]
        return this.basicSet[aFeature.name.toUpperFirst()/](null, notifications);
    [/if]
[/for]
    default:
        return super.eBasicInverseRemove(otherEnd, featureID, notifications);
    }
}
[/let]
[/template]
