[**
 * This file is part of soft.generator.ts, a project for typescript 
 * code generation of an ecore model
 *
 * Copyright(c) 2021 MASA Group
 *	
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, value. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
**/]

[comment encoding = UTF-8 /]
[module generateImplementationTests('http://www.eclipse.org/emf/2002/Ecore')/]


[import soft::generator::common::generateCommon/]
[import soft::generator::common::generateElement/]
[import soft::generator::common::generateStructuralFeature/]
[import soft::generator::ts::generateCommon /]
[import soft::generator::ts::generateElement /]
[import soft::generator::ts::generateType /]
[import soft::generator::ts::lib::generateCommon /]
[import soft::generator::ts::lib::generateReflectives /]

[template public generateImplementationTests(aClass : EClass) { 
	aPackage : EPackage = aClass.ePackage;
	className : String = aClass.getImplementationName();
	features : Collection(EStructuralFeature) = aClass.getImplementedFeatures()->sortedBy( getVariableName() );
}]
[file (aClass.ePackage.getOutputDirectory() + '/' + aClass.getImplementationTestFileName( aClass.name ), false, 'UTF-8')]
[fileComment()/]

[comment imports/]
import { anything , capture, instance, mock, reset, verify, when } from "ts-mockito";
[let allTypes : OrderedSet(String) = Set{ aClass.getReferencedTypes()->collect( o | o.getType() )->asSet()
                                        , if aClass.requiresMap() then Set{ 'ecore.EMap', 'ecore.BasicEObjectMap', 'ecore.EMapEntry' } else Set{} endif
                                        , if aClass.requiresList() then Set{ 'ecore.EList', 'ecore.BasicEList', 'ecore.BasicEObjectList', aPackage.getQualifiedConstantsName() } else Set{} endif
                                        , if aClass.hasReflectives() then Set{'ecore.EObject','ecore.EObjectInternal','ecore.EList','ecore.ENotifyingList','ecore.ENotificationChain','ecore.isEObjectList'} else Set{} endif
                                        , if features->exists(requiresNotification()) then Set{'ecore.ENotification','ecore.ENotificationChain','ecore.EventType','ecore.Notification','ecore.EOPPOSITE_FEATURE_BASE', aPackage.getQualifiedConstantsName() } else Set{} endif
                                        , if features->exists(isContainer()) then Set{aPackage.getQualifiedConstantsName()} else Set{} endif
                                        , Set {aClass.getQualifiedImplementationName(), aPackage.name + '.' + 'get'+ aPackage.getInterfaceName()}
                                        , Set {'ecore.EResource', 'ecore.EResourceSet', 'ecore.EAdapter'}
                                        }->flatten()->select(s | s <> '')->asOrderedSet()->sortedBy(s | s)]
[aPackage.generateImports(allTypes,aClass.getImplementationTestFileName( aClass.name ))/]
[/let]

[comment mock types defined in get/set methods/]
[let ecorePrefix : String = if not aClass.ePackage.isEcorePackage() then 'ecore.' else '' endif]
[let mockTypes : OrderedSet(EClass) = features->select(oclIsKindOf(EReference) and eType.oclIsKindOf(EClass) and eType.name <> 'EObject')
											  ->collect(eType.oclAsType(EClass))->asOrderedSet()->sortedBy(name)]
[for (mockType: EClass | mockTypes)]
interface [mockType.getInterfaceName()/]Internal extends [getShortQualifiedName(mockType.getQualifiedInterfaceName(),aPackage.name)/], [ecorePrefix/]EObjectInternal {} 
[/for]
[/let]
[/let]

describe("[className/]", () => {
	
	test("eStaticClass", () => {
        let o = new [className/]()
		expect(o.eStaticClass()).toBe(get[aPackage.getInterfaceName()/]().[aClass.getReflectiveGetterName()/]());
    });

	[aClass.getImplementedFeatures()->sortedBy( getVariableName() ).generateTestFeature(aClass)/]
	[aClass.getImplementedOperations()->sortedBy( getOperationName() )->select(isDefault()).generateTestOperation(aClass)/]

})

[/file]
[/template]


[template private generateTestFeature(aStructuralFeature : EStructuralFeature, aClass : EClass )]
[if isGet()]

[aStructuralFeature.generateGetTestImplementation(aClass)/]
[/if]
[if isSet()]

[aStructuralFeature.generateSetTestImplementation(aClass)/]
[/if]
[if isBasicSet()]

[aStructuralFeature.generateBasicSetTestImplementation(aClass)/]
[/if]
[if isUnSet()]

[aStructuralFeature.generateUnSetTestImplementation(aClass)/]
[/if]
[/template]

[template private generateGetTestImplementation(aStructuralFeature : EStructuralFeature,aClass : EClass) ? (isVolatile())]
test("get[aStructuralFeature.name.toUpperFirst()/]", () => {
	let o = new [aClass.getImplementationName()/]()
	expect(() => o.[aStructuralFeature.getPropertyName()/]).toThrow(Error);
})
[/template]

[template private generateGetTestImplementation(aStructuralFeature : EStructuralFeature,aClass : EClass) ? (isContainer())]
[let ecorePrefix : String = if not aClass.ePackage.isEcorePackage() then 'ecore.' else '' endif]
test("get[aStructuralFeature.name.toUpperFirst()/]", () => {
	// default
	let o = new [aClass.getImplementationName()/]();
	expect(o.[aStructuralFeature.getPropertyName()/]).toBeNull();

	// set a mock container
	let mockContainer = mock<[ecorePrefix/]EObject>();
	let container = instance(mockContainer)
	o.eSetInternalContainer(container,[aClass.getQualifiedIDName(aStructuralFeature)/]);
	
	// no proxy
	when(mockContainer.eIsProxy()).thenReturn(false);
	expect(o.[aStructuralFeature.getPropertyName()/]).toBe(container);
	verify(mockContainer.eIsProxy()).once();
})
[/let]
[/template]

[template private generateGetTestImplementation(aStructuralFeature : EStructuralFeature,aClass : EClass) ? (isMapType())]
test("get[aStructuralFeature.name.toUpperFirst()/]", () => {
	let o = new [aClass.getImplementationName()/]();
	expect(o.[aStructuralFeature.getPropertyName()/]).not.toBeNull();
})
[/template]

[template private generateGetTestImplementation(aStructuralFeature : EStructuralFeature,aClass : EClass) ? (isListType())]
test("get[aStructuralFeature.name.toUpperFirst()/]", () => {
	let o = new [aClass.getImplementationName()/]();
	[if aStructuralFeature.eType.name = 'EFeatureMapEntry']
	expect(o.[aStructuralFeature.getPropertyName()/]).toBeNull();
	[else]
	expect(o.[aStructuralFeature.getPropertyName()/]).not.toBeNull();
	[/if]
})
[/template]

[template private generateGetTestImplementation(aStructuralFeature : EStructuralFeature,aClass : EClass) ? (oclIsKindOf(EReference) and isLazy())]
test("get[aStructuralFeature.name.toUpperFirst()/]", () => {
	let o = new [aClass.getImplementationName()/]();
	expect(() => o.[aStructuralFeature.getPropertyName()/]).toThrow(Error);
})
[/template]

[template private generateGetTestImplementation(aStructuralFeature : EStructuralFeature, aClass : EClass) ? (oclIsKindOf(EReference) and isProxy())]
[let ecorePrefix : String = if not aClass.ePackage.isEcorePackage() then 'ecore.' else '' endif]
[let eRefType : EClass = aStructuralFeature.eType.oclAsType(EClass)]
test("get[aStructuralFeature.name.toUpperFirst()/]", () => {
	let o = new [aClass.getImplementationName()/]();
	
	// get default value
	expect(o.[aStructuralFeature.getPropertyName()/]).toBeNull();
	
	// initialize object with a mock value
	let mockValue = mock<[getShortQualifiedName( eRefType.getQualifiedInterfaceName() + 'Internal' , aClass.ePackage.name )/]>();
	let value = instance(mockValue);
	o.[aStructuralFeature.getPropertyName()/] = value;
	
	// events
	let mockAdapter = mock<[ecorePrefix/]EAdapter>();
	let adapter = instance(mockAdapter);
	o.eAdapters.add(adapter);
	
	// set object resource
	let mockResourceSet = mock<[ecorePrefix/]EResourceSet>();
	let resourceSet = instance(mockResourceSet);
	let mockResource = mock<[ecorePrefix/]EResource>();
	let resource = instance(mockResource);
	o.eSetInternalResource(resource);

	// get non resolved value
	when(mockValue.eIsProxy()).thenReturn(false)
	expect(o.[aStructuralFeature.getPropertyName()/]).toBe(value);
	verify(mockValue.eIsProxy()).once()

	// get a resolved value
	let mockURI = new URL("test:///file.t");
	let mockResolved = mock<[getShortQualifiedName( eRefType.getQualifiedInterfaceName() + 'Internal' , aClass.ePackage.name )/]>();
	let resolved = instance(mockResolved);
	when(mockResolved.eProxyURI()).thenReturn(null)
	when(mockResource.eResourceSet()).thenReturn(resourceSet)
	when(mockResourceSet.getEObject(mockURI,true)).thenReturn(resolved)
	when(mockValue.eIsProxy()).thenReturn(true)
	when(mockValue.eProxyURI()).thenReturn(mockURI)
	expect(o.[aStructuralFeature.getPropertyName()/]).toBe(resolved);
})
[/let]
[/let]
[/template]

[template private generateGetTestImplementation(aStructuralFeature : EStructuralFeature,aClass : EClass) ? (oclIsKindOf(EReference))]
test("get[aStructuralFeature.name.toUpperFirst()/]", () => {
	let o = new [aClass.getImplementationName()/]();
	
	// get default value
	expect(o.[aStructuralFeature.getPropertyName()/]).toBeNull();
})
[/template]

[template private generateGetTestImplementation(aStructuralFeature : EStructuralFeature,aClass : EClass) ? (oclIsKindOf(EAttribute))]
test("get[aStructuralFeature.name.toUpperFirst()/]", () => {
	let o = new [aClass.getImplementationName()/]();
	// get default value
	[let aAttribute : EAttribute = aStructuralFeature.oclAsType(EAttribute)]
	[let aDefaultValue : String = aAttribute.getDefaultValue(aClass)]
	[if aDefaultValue = '']
	expect(o.[aStructuralFeature.getPropertyName()/]).toBeNull();
	[else]
	expect(o.[aStructuralFeature.getPropertyName()/]).toBe([aDefaultValue/]);
	[/if]
	[/let]
	[/let]
})
[/template]


[template private generateGetTestImplementation(aStructuralFeature : EStructuralFeature,aClass : EClass)]
[/template]

[template private generateSetTestImplementation(aStructuralFeature : EStructuralFeature,aClass : EClass) ?(isVolatile())]
test("set[aStructuralFeature.name.toUpperFirst()/]", () => {
	let o = new [aClass.getImplementationName()/]();
	[aStructuralFeature.eType.generateTestValue(aClass.ePackage)/]	
	expect(() => o.[aStructuralFeature.getPropertyName()/] = value).toThrow(Error);
})
[/template]

[template private generateSetTestImplementation(aStructuralFeature : EStructuralFeature,aClass : EClass) ?(isContainer())]
[let ecorePrefix : String = if not aClass.ePackage.isEcorePackage() then 'ecore.' else '' endif]
[let reverseFeature : EStructuralFeature = aStructuralFeature.oclAsType(EReference).eOpposite]
[let reverseClass : EClass = reverseFeature.eContainingClass]
test("set[aStructuralFeature.name.toUpperFirst()/]", () => {
	let o = new [aClass.getImplementationName()/]();
	let mockResource = mock<[ecorePrefix/]EResource>();
	let resource = instance(mockResource);
	[aStructuralFeature.eType.generateTestValue(aClass.ePackage)/]

	// add listener
	let mockAdapter = mock<[ecorePrefix/]EAdapter>();
	let adapter = instance(mockAdapter);
	o.eAdapters.add(adapter);
	
	// set value
	when(mockValue.eInverseAdd(o,[reverseClass.getQualifiedIDName(reverseFeature)/],null)).thenReturn(null);
	when(mockValue.eResource()).thenReturn(resource);
	o.[aStructuralFeature.getPropertyName()/] = value;
	verify(mockResource.attached(o)).once();
	verify(mockAdapter.notifyChanged(anything())).once(); 
	let ['['/]notification[']'/] = capture(mockAdapter.notifyChanged).last();
	expect(notification.notifier).toBe(o)
	expect(notification.oldValue).toBeNull();
	expect(notification.newValue).toBe(value);
	
	// set with the same value
	reset(mockAdapter);
	o.[aStructuralFeature.getPropertyName()/] = value;
	verify(mockAdapter.notifyChanged(anything())).once();

	// set with another value in a different resource
	[aStructuralFeature.eType.generateTestOtherValue(aClass.ePackage)/]
	let mockOtherResource = mock<[ecorePrefix/]EResource>();
	let otherResource = instance(mockOtherResource)
	reset(mockAdapter);
	reset(mockValue);
	reset(mockResource);	
	when(mockValue.eInverseRemove(o,[reverseClass.getQualifiedIDName(reverseFeature)/],null)).thenReturn(null);
	when(mockValue.eResource()).thenReturn(resource);
	when(mockOther.eInverseAdd(o,[reverseClass.getQualifiedIDName(reverseFeature)/],null)).thenReturn(null);
	when(mockOther.eResource()).thenReturn(otherResource);
	o.[aStructuralFeature.getPropertyName()/] = other;
	verify(mockResource.detached(o)).once();
	verify(mockOtherResource.attached(o)).once();
	verify(mockAdapter.notifyChanged(anything())).once();
	['['/]notification[']'/] = capture(mockAdapter.notifyChanged).last();
	expect(notification.notifier).toBe(o)
	expect(notification.oldValue).toBe(value);
	expect(notification.newValue).toBe(other);
	expect(notification.position).toBe(-1);
})
[/let]
[/let]
[/let]
[/template]

[template private generateSetTestImplementation(aStructuralFeature : EStructuralFeature,aClass : EClass) ?(isBidirectional())]
[let ecorePrefix : String = if not aClass.ePackage.isEcorePackage() then 'ecore.' else '' endif]
[let reverseFeature : EStructuralFeature = aStructuralFeature.oclAsType(EReference).eOpposite]
[let reverseClass : EClass = reverseFeature.eContainingClass]
test("set[aStructuralFeature.name.toUpperFirst()/]", () => {
	let o = new [aClass.getImplementationName()/]();
	
	// add listener
	let mockAdapter = mock<[ecorePrefix/]EAdapter>();
	let adapter = instance(mockAdapter);
	o.eAdapters.add(adapter);
	
	// first value
	[aStructuralFeature.eType.generateTestValue(aClass.ePackage)/]
	when(mockValue.eInverseAdd(o,[reverseClass.getQualifiedIDName(reverseFeature)/],null)).thenReturn(null);
	o.[aStructuralFeature.getPropertyName()/] = value;
	verify(mockAdapter.notifyChanged(anything())).once(); 
	let ['['/]notification[']'/] = capture(mockAdapter.notifyChanged).last();
	expect(notification.notifier).toBe(o)
	expect(notification.oldValue).toBeNull();
	expect(notification.newValue).toBe(value);
	
	// set with other value
	[aStructuralFeature.eType.generateTestOtherValue(aClass.ePackage)/]
	reset(mockAdapter);
	reset(mockValue);
	when(mockValue.eInverseRemove(o,[reverseClass.getQualifiedIDName(reverseFeature)/],null)).thenReturn(null);
	when(mockOther.eInverseAdd(o,[reverseClass.getQualifiedIDName(reverseFeature)/],null)).thenReturn(null);
	o.[aStructuralFeature.getPropertyName()/] = other;
	verify(mockAdapter.notifyChanged(anything())).once();
	['['/]notification[']'/] = capture(mockAdapter.notifyChanged).last();
	expect(notification.notifier).toBe(o)
	expect(notification.oldValue).toBe(value);
	expect(notification.newValue).toBe(other);
	expect(notification.position).toBe(-1);
})
[/let]
[/let]
[/let]
[/template]

[template private generateSetTestImplementation(aStructuralFeature : EStructuralFeature,aClass : EClass)]
[let ecorePrefix : String = if not aClass.ePackage.isEcorePackage() then 'ecore.' else '' endif]
[let aPackage : EPackage = aClass.ePackage ]
test("set[aStructuralFeature.name.toUpperFirst()/]", () => {
	let o = new [aClass.getImplementationName()/]();
	[aStructuralFeature.eType.generateTestValue(aPackage)/]

	// add listener
	let mockAdapter = mock<[ecorePrefix/]EAdapter>();
	let adapter = instance(mockAdapter);
	o.eAdapters.add(adapter);

	// set value
	o.[aStructuralFeature.getPropertyName()/] = value;

	// checks
	verify(mockAdapter.notifyChanged(anything())).once();
	const ['['/]notification[']'/] = capture(mockAdapter.notifyChanged).last();
	expect(notification.notifier).toBe(o)
[let defaultValue : String = aStructuralFeature.getDefaultValue(aClass)]
[if defaultValue = 'null']
	expect(notification.oldValue).toBeNull();
[else]
	expect(notification.oldValue).toBe([defaultValue/]);
[/if]
[/let]
	expect(notification.newValue).toBe(value);
	expect(notification.position).toBe(-1);
})
[/let]
[/let]
[/template]


[template private generateBasicSetTestImplementation(aStructuralFeature : EStructuralFeature,aClass : EClass)]
[let ecorePrefix : String = if not aClass.ePackage.isEcorePackage() then 'ecore.' else '' endif]
[let aPackage : EPackage = aClass.ePackage ]
test("basicSet[aStructuralFeature.name.toUpperFirst()/]", () => {
	let o = new [aClass.getImplementationName()/]();
	[aStructuralFeature.eType.generateTestValue(aPackage)/]

	// add listener
	let mockAdapter = mock<[ecorePrefix/]EAdapter>();
	let adapter = instance(mockAdapter);
	o.eAdapters.add(adapter);

	// notification chain
	let mockNotifications = mock<[ecorePrefix/]ENotificationChain>();
	let notifications = instance(mockNotifications);

	// set value
[if isContainer()]
	when(mockValue.eResource()).thenReturn(null)
[/if]
	when(mockNotifications.add(anything())).thenReturn(true)
	o.basicSet[aStructuralFeature.getPropertyName().toUpperFirst()/](value,notifications);

	// checks
	verify(mockNotifications.add(anything())).once();
	const ['['/]notification[']'/] = capture(mockNotifications.add).last();
	expect(notification.notifier).toBe(o)
	expect(notification.eventType).toBe([ecorePrefix/]EventType.SET);
	expect(notification.featureID).toBe([aClass.getQualifiedIDName(aStructuralFeature)/]);
[let defaultValue : String = aStructuralFeature.getDefaultValue(aClass)]
[if defaultValue = 'null']
	expect(notification.oldValue).toBeNull();
[else]
	expect(notification.oldValue).toBe([defaultValue/]);
[/if]
[/let]
	expect(notification.newValue).toBe(value);
	expect(notification.position).toBe(-1);
})
[/let]
[/let]
[/template]

[template private generateUnSetTestImplementation(aStructuralFeature : EStructuralFeature,aClass : EClass) ?(isVolatile())]
test("unset[aStructuralFeature.name.toUpperFirst()/]", () => {
	let o = new [aClass.getImplementationName()/]();
	expect(() => o.[aStructuralFeature.getUnSetterName()/]()).toThrow(Error);
})
[/template]

[template private generateUnSetTestImplementation(aStructuralFeature : EStructuralFeature,aClass : EClass) ?(isListType())]
test("unset[aStructuralFeature.name.toUpperFirst()/]", () => {
	let o = new [aClass.getImplementationName()/]();
	o.[aStructuralFeature.getUnSetterName()/]();
	expect(o.[aStructuralFeature.getPropertyName()/].isEmpty()).toBeTruthy();
})
[/template]

[template private generateUnSetTestImplementation(aStructuralFeature : EStructuralFeature,aClass : EClass)]
[let ecorePrefix : String = if not aClass.ePackage.isEcorePackage() then 'ecore.' else '' endif]
test("unset[aStructuralFeature.name.toUpperFirst()/]", () => {
	let o = new [aClass.getImplementationName()/]();
	
	// add listener
	let mockAdapter = mock<[ecorePrefix/]EAdapter>();
	let adapter = instance(mockAdapter);
	o.eAdapters.add(adapter);

	// unset
	o.[aStructuralFeature.getUnSetterName()/]();

	// checks
	verify(mockAdapter.notifyChanged(anything())).once();
	const ['['/]notification[']'/] = capture(mockAdapter.notifyChanged).last();
	expect(notification.notifier).toBe(o)
	expect(notification.eventType).toBe([ecorePrefix/]EventType.UNSET);
	expect(notification.featureID).toBe([aClass.getQualifiedIDName(aStructuralFeature)/]);	
[let defaultValue : String = aStructuralFeature.getDefaultValue(aClass)]
[if defaultValue = 'null']
	expect(o.[aStructuralFeature.getPropertyName()/]).toBeNull();
[else]
	expect(o.[aStructuralFeature.getPropertyName()/]).toBe([defaultValue/]);
[/if]
[/let]
})
[/let]
[/template]


[template private generateTestValue(aClass : EClass, aPackage : EPackage )]
let mockValue = mock<[getShortQualifiedName(aClass.getQualifiedInterfaceName() + 'Internal', aPackage.name)/]>();
let value = instance(mockValue);
[/template]

[template private generateTestValue(aDataType : EDataType, aPackage : EPackage )]
let value = [aDataType.getTestValue(aPackage)/];
[/template]

[template private generateTestValue(aEEnum : EEnum, aPackage : EPackage )]
let value = [aEEnum.getTestValue(aPackage)/];
[/template]

[template private generateTestValue(aClassifier : EClassifier, aPackage : EPackage )]
let value = null
[/template]

[template private generateTestOtherValue(aClass : EClass, aPackage : EPackage )]
let mockOther = mock<[getShortQualifiedName(aClass.getQualifiedInterfaceName() + 'Internal', aPackage.name)/]>();
let other = instance(mockOther);
[/template]


[template private generateTestOtherValue(aClassifier : EClassifier, aPackage : EPackage )]
[/template]


[template private generateTestOperation(anEOperation : EOperation, aClass : EClass )]
test("[anEOperation.getOperationName()/]", () => {
	let o = new([aClass.getImplementationName()/])
	expect(() => o.[anEOperation.getOperationName()/]([for (eClassifier : EClassifier | anEOperation.eParameters.eType) separator(',')][eClassifier.getDefaultValue(aClass)/][/for])).toThrow(Error);
})

[/template]
