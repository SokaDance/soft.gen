[**
 * This file is part of soft.generator.ts, a project for typescript 
 * code generation of an ecore model
 *
 * Copyright(c) 2021 MASA Group
 *	
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, value. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
**/]

[comment encoding = UTF-8 /]
[module generateImplementationTests('http://www.eclipse.org/emf/2002/Ecore')/]


[import soft::generator::common::generateCommon/]
[import soft::generator::common::generateElement/]
[import soft::generator::common::generateReflectives/]
[import soft::generator::common::generateStructuralFeature/]
[import soft::generator::ts::generateCommon /]
[import soft::generator::ts::generateElement /]
[import soft::generator::ts::generateType /]
[import soft::generator::ts::lib::generateCommon /]
[import soft::generator::ts::lib::generateReflectives /]

[query private isFeatureMap(aStructuralFeature : EStructuralFeature) : Boolean = isListType() and eType.name = 'EFeatureMapEntry'/]


[template public generateImplementationTests(aClass : EClass) { 
	aPackage : EPackage = aClass.ePackage;
	className : String = aClass.getImplementationName();
	features : Collection(EStructuralFeature) = aClass.getImplementedFeatures()->sortedBy( getVariableName() );
}]
[file (aClass.ePackage.getOutputDirectory() + '/' + aClass.getImplementationTestFileName( aClass.name ), false, 'UTF-8')]
[fileComment()/]

[comment imports/]
[if aClass.requiresList()]
import * as deepEqual from "deep-equal";
[/if]
import { anything , capture, instance, mock, reset, verify, when } from "ts-mockito";
[let allTypes : OrderedSet(String) = Set{ aClass.getReferencedTypes()->collect( o | o.getType() )->asSet()
                                        , if aClass.requiresMap() then Set{ 'ecore.EMap', 'ecore.EMapEntry' } else Set{} endif
                                        , if aClass.requiresList() then Set{ 'ecore.EList', 'ecore.EObjectList','ecore.ImmutableEList','ecore.EOPPOSITE_FEATURE_BASE',aPackage.getQualifiedConstantsName() } else Set{} endif
                                        , if aClass.hasReflectives() then Set{'ecore.EObject','ecore.EObjectInternal','ecore.EList','ecore.ENotifyingList','ecore.ENotificationChain','ecore.isEObjectList'} else Set{} endif
                                        , if features->exists(requiresNotification()) then Set{'ecore.ENotification','ecore.ENotificationChain','ecore.EventType','ecore.Notification','ecore.EOPPOSITE_FEATURE_BASE', aPackage.getQualifiedConstantsName() } else Set{} endif
                                        , if features->exists(isContainer()) then Set{aPackage.getQualifiedConstantsName()} else Set{} endif
                                        , Set {aClass.getQualifiedImplementationName(), aPackage.name + '.' + 'get'+ aPackage.getInterfaceName()}
                                        , Set {'ecore.EResource', 'ecore.EResourceSet', 'ecore.EAdapter'}
                                        }->flatten()->select(s | s <> '')->asOrderedSet()->sortedBy(s | s)]
[aPackage.generateImports(allTypes,aClass.getImplementationTestFileName( aClass.name ))/]
[/let]

[comment mock types defined in get/set methods/]
[let ecorePrefix : String = if not aClass.ePackage.isEcorePackage() then 'ecore.' else '' endif]
[let mockTypes : OrderedSet(EClass) = features->select(oclIsKindOf(EReference) and eType.oclIsKindOf(EClass) and eType.name <> 'EObject')
											  ->collect(eType.oclAsType(EClass))->asOrderedSet()->sortedBy(name)]
[for (mockType: EClass | mockTypes)]
interface [mockType.getInterfaceName()/]Internal extends [getShortQualifiedName(mockType.getQualifiedInterfaceName(),aPackage.name)/], [ecorePrefix/]EObjectInternal {} 
[/for]
[/let]
[/let]

describe("[className/]", () => {
	
	test("eStaticClass", () => {
        let o = new [className/]()
		expect(o.eStaticClass()).toBe(get[aPackage.getInterfaceName()/]().[aClass.getReflectiveGetterName()/]());
    });

	[aClass.getImplementedFeatures()->sortedBy( getVariableName() ).generateTestFeature(aClass)/]
	[aClass.getImplementedOperations()->sortedBy( getOperationName() )->select(isDefault()).generateTestOperation(aClass)/]
	[aClass.generateElementIDTestImplementation()/]
	[aClass.generateEGetFromIDTestImplementation()/]
	[aClass.generateESetFromIDTestImplementation()/]
	[aClass.generateEIsSetFromIDTestImplementation()/]
	[aClass.generateEUnSetFromIDTestImplementation()/]
	[aClass.generateEInvokeFromIDTestImplementation()/]
	[aClass.generateEInverseAddTestImplementation()/]
	[aClass.generateEInverseRemoveTestImplementation()/]

})

[/file]
[/template]


[template private generateTestFeature(aStructuralFeature : EStructuralFeature, aClass : EClass )]
[if isGet()]

[aStructuralFeature.generateGetTestImplementation(aClass)/]
[/if]
[if isSet()]

[aStructuralFeature.generateSetTestImplementation(aClass)/]
[/if]
[if isBasicSet()]

[aStructuralFeature.generateBasicSetTestImplementation(aClass)/]
[/if]
[if isUnSet()]

[aStructuralFeature.generateUnSetTestImplementation(aClass)/]
[/if]
[/template]

[template private generateGetTestImplementation(aStructuralFeature : EStructuralFeature,aClass : EClass) ? (isVolatile())]
test("get[aStructuralFeature.name.toUpperFirst()/]", () => {
	let o = new [aClass.getImplementationName()/]()
	expect(() => o.[aStructuralFeature.getPropertyName()/]).toThrow(Error);
})
[/template]

[template private generateGetTestImplementation(aStructuralFeature : EStructuralFeature,aClass : EClass) ? (isContainer())]
[let ecorePrefix : String = if not aClass.ePackage.isEcorePackage() then 'ecore.' else '' endif]
test("get[aStructuralFeature.name.toUpperFirst()/]", () => {
	// default
	let o = new [aClass.getImplementationName()/]();
	expect(o.[aStructuralFeature.getPropertyName()/]).toBeNull();

	// set a mock container
	let mockContainer = mock<[ecorePrefix/]EObject>();
	let container = instance(mockContainer)
	o.eSetInternalContainer(container,[aClass.getQualifiedIDName(aStructuralFeature)/]);
	
	// no proxy
	when(mockContainer.eIsProxy()).thenReturn(false);
	expect(o.[aStructuralFeature.getPropertyName()/]).toBe(container);
	verify(mockContainer.eIsProxy()).once();
})
[/let]
[/template]

[template private generateGetTestImplementation(aStructuralFeature : EStructuralFeature,aClass : EClass) ? (isMapType())]
test("get[aStructuralFeature.name.toUpperFirst()/]", () => {
	let o = new [aClass.getImplementationName()/]();
	expect(o.[aStructuralFeature.getPropertyName()/]).not.toBeNull();
})
[/template]

[template private generateGetTestImplementation(aStructuralFeature : EStructuralFeature,aClass : EClass) ? (isListType())]
test("get[aStructuralFeature.name.toUpperFirst()/]", () => {
	let o = new [aClass.getImplementationName()/]();
	[if aStructuralFeature.eType.name = 'EFeatureMapEntry']
	expect(o.[aStructuralFeature.getPropertyName()/]).toBeNull();
	[else]
	expect(o.[aStructuralFeature.getPropertyName()/]).not.toBeNull();
	[/if]
})
[/template]

[template private generateGetTestImplementation(aStructuralFeature : EStructuralFeature,aClass : EClass) ? (oclIsKindOf(EReference) and isLazy())]
test("get[aStructuralFeature.name.toUpperFirst()/]", () => {
	let o = new [aClass.getImplementationName()/]();
	expect(() => o.[aStructuralFeature.getPropertyName()/]).toThrow(Error);
})
[/template]

[template private generateGetTestImplementation(aStructuralFeature : EStructuralFeature, aClass : EClass) ? (oclIsKindOf(EReference) and isProxy())]
[let ecorePrefix : String = if not aClass.ePackage.isEcorePackage() then 'ecore.' else '' endif]
[let eRefType : EClass = aStructuralFeature.eType.oclAsType(EClass)]
test("get[aStructuralFeature.name.toUpperFirst()/]", () => {
	let o = new [aClass.getImplementationName()/]();
	
	// get default value
	expect(o.[aStructuralFeature.getPropertyName()/]).toBeNull();
	
	// initialize object with a mock value
	let mockValue = mock<[getShortQualifiedName( eRefType.getQualifiedInterfaceName() + 'Internal' , aClass.ePackage.name )/]>();
	let value = instance(mockValue);
	o.[aStructuralFeature.getPropertyName()/] = value;
	
	// events
	let mockAdapter = mock<[ecorePrefix/]EAdapter>();
	let adapter = instance(mockAdapter);
	o.eAdapters.add(adapter);
	
	// set object resource
	let mockResourceSet = mock<[ecorePrefix/]EResourceSet>();
	let resourceSet = instance(mockResourceSet);
	let mockResource = mock<[ecorePrefix/]EResource>();
	let resource = instance(mockResource);
	o.eSetInternalResource(resource);

	// get non resolved value
	when(mockValue.eIsProxy()).thenReturn(false)
	expect(o.[aStructuralFeature.getPropertyName()/]).toBe(value);
	verify(mockValue.eIsProxy()).once()

	// get a resolved value
	let mockURI = new URL("test:///file.t");
	let mockResolved = mock<[getShortQualifiedName( eRefType.getQualifiedInterfaceName() + 'Internal' , aClass.ePackage.name )/]>();
	let resolved = instance(mockResolved);
	when(mockResolved.eProxyURI()).thenReturn(null)
	when(mockResource.eResourceSet()).thenReturn(resourceSet)
	when(mockResourceSet.getEObject(mockURI,true)).thenReturn(resolved)
	when(mockValue.eIsProxy()).thenReturn(true)
	when(mockValue.eProxyURI()).thenReturn(mockURI)
	expect(o.[aStructuralFeature.getPropertyName()/]).toBe(resolved);
})
[/let]
[/let]
[/template]

[template private generateGetTestImplementation(aStructuralFeature : EStructuralFeature,aClass : EClass) ? (oclIsKindOf(EReference))]
test("get[aStructuralFeature.name.toUpperFirst()/]", () => {
	let o = new [aClass.getImplementationName()/]();
	
	// get default value
	expect(o.[aStructuralFeature.getPropertyName()/]).toBeNull();
})
[/template]

[template private generateGetTestImplementation(aStructuralFeature : EStructuralFeature,aClass : EClass) ? (oclIsKindOf(EAttribute))]
test("get[aStructuralFeature.name.toUpperFirst()/]", () => {
	let o = new [aClass.getImplementationName()/]();
	// get default value
	[let aAttribute : EAttribute = aStructuralFeature.oclAsType(EAttribute)]
	[let aDefaultValue : String = aAttribute.getDefaultValue(aClass)]
	[if aDefaultValue = '']
	expect(o.[aStructuralFeature.getPropertyName()/]).toBeNull();
	[else]
	expect(o.[aStructuralFeature.getPropertyName()/]).toBe([aDefaultValue/]);
	[/if]
	[/let]
	[/let]
})
[/template]


[template private generateGetTestImplementation(aStructuralFeature : EStructuralFeature,aClass : EClass)]
[/template]

[template private generateSetTestImplementation(aStructuralFeature : EStructuralFeature,aClass : EClass) ?(isVolatile())]
test("set[aStructuralFeature.name.toUpperFirst()/]", () => {
	let o = new [aClass.getImplementationName()/]();
	[aStructuralFeature.eType.generateTestValue(aClass.ePackage,'value')/]	
	expect(() => o.[aStructuralFeature.getPropertyName()/] = value).toThrow(Error);
})
[/template]

[template private generateSetTestImplementation(aStructuralFeature : EStructuralFeature,aClass : EClass) ?(isContainer())]
[let ecorePrefix : String = if not aClass.ePackage.isEcorePackage() then 'ecore.' else '' endif]
[let reverseFeature : EStructuralFeature = aStructuralFeature.oclAsType(EReference).eOpposite]
[let reverseClass : EClass = reverseFeature.eContainingClass]
test("set[aStructuralFeature.name.toUpperFirst()/]", () => {
	let o = new [aClass.getImplementationName()/]();
	let mockResource = mock<[ecorePrefix/]EResource>();
	let resource = instance(mockResource);
	[aStructuralFeature.eType.generateTestValue(aClass.ePackage,'value')/]

	// add listener
	let mockAdapter = mock<[ecorePrefix/]EAdapter>();
	let adapter = instance(mockAdapter);
	o.eAdapters.add(adapter);
	
	// set value
	when(mockValue.eInverseAdd(o,[reverseClass.getQualifiedIDName(reverseFeature)/],null)).thenReturn(null);
	when(mockValue.eResource()).thenReturn(resource);
	o.[aStructuralFeature.getPropertyName()/] = value;
	verify(mockResource.attached(o)).once();
	verify(mockAdapter.notifyChanged(anything())).once(); 
	let ['['/]notification[']'/] = capture(mockAdapter.notifyChanged).last();
	expect(notification.notifier).toBe(o)
	expect(notification.oldValue).toBeNull();
	expect(notification.newValue).toBe(value);
	
	// set with the same value
	reset(mockAdapter);
	o.[aStructuralFeature.getPropertyName()/] = value;
	verify(mockAdapter.notifyChanged(anything())).once();

	// set with another value in a different resource
	[aStructuralFeature.eType.generateTestValue(aClass.ePackage,'other')/]
	let mockOtherResource = mock<[ecorePrefix/]EResource>();
	let otherResource = instance(mockOtherResource)
	reset(mockAdapter);
	reset(mockValue);
	reset(mockResource);	
	when(mockValue.eInverseRemove(o,[reverseClass.getQualifiedIDName(reverseFeature)/],null)).thenReturn(null);
	when(mockValue.eResource()).thenReturn(resource);
	when(mockOther.eInverseAdd(o,[reverseClass.getQualifiedIDName(reverseFeature)/],null)).thenReturn(null);
	when(mockOther.eResource()).thenReturn(otherResource);
	o.[aStructuralFeature.getPropertyName()/] = other;
	verify(mockResource.detached(o)).once();
	verify(mockOtherResource.attached(o)).once();
	verify(mockAdapter.notifyChanged(anything())).once();
	['['/]notification[']'/] = capture(mockAdapter.notifyChanged).last();
	expect(notification.notifier).toBe(o)
	expect(notification.oldValue).toBe(value);
	expect(notification.newValue).toBe(other);
	expect(notification.position).toBe(-1);
})
[/let]
[/let]
[/let]
[/template]

[template private generateSetTestImplementation(aStructuralFeature : EStructuralFeature,aClass : EClass) ?(isBidirectional())]
[let ecorePrefix : String = if not aClass.ePackage.isEcorePackage() then 'ecore.' else '' endif]
[let reverseFeature : EStructuralFeature = aStructuralFeature.oclAsType(EReference).eOpposite]
[let reverseClass : EClass = reverseFeature.eContainingClass]
test("set[aStructuralFeature.name.toUpperFirst()/]", () => {
	let o = new [aClass.getImplementationName()/]();
	
	// add listener
	let mockAdapter = mock<[ecorePrefix/]EAdapter>();
	let adapter = instance(mockAdapter);
	o.eAdapters.add(adapter);
	
	// first value
	[aStructuralFeature.eType.generateTestValue(aClass.ePackage,'value')/]
	when(mockValue.eInverseAdd(o,[reverseClass.getQualifiedIDName(reverseFeature)/],null)).thenReturn(null);
	o.[aStructuralFeature.getPropertyName()/] = value;
	verify(mockAdapter.notifyChanged(anything())).once(); 
	let ['['/]notification[']'/] = capture(mockAdapter.notifyChanged).last();
	expect(notification.notifier).toBe(o)
	expect(notification.oldValue).toBeNull();
	expect(notification.newValue).toBe(value);
	
	// set with other value
	[aStructuralFeature.eType.generateTestValue(aClass.ePackage,'other')/]
	reset(mockAdapter);
	reset(mockValue);
	when(mockValue.eInverseRemove(o,[reverseClass.getQualifiedIDName(reverseFeature)/],null)).thenReturn(null);
	when(mockOther.eInverseAdd(o,[reverseClass.getQualifiedIDName(reverseFeature)/],null)).thenReturn(null);
	o.[aStructuralFeature.getPropertyName()/] = other;
	verify(mockAdapter.notifyChanged(anything())).once();
	['['/]notification[']'/] = capture(mockAdapter.notifyChanged).last();
	expect(notification.notifier).toBe(o)
	expect(notification.oldValue).toBe(value);
	expect(notification.newValue).toBe(other);
	expect(notification.position).toBe(-1);
})
[/let]
[/let]
[/let]
[/template]

[template private generateSetTestImplementation(aStructuralFeature : EStructuralFeature,aClass : EClass)]
[let ecorePrefix : String = if not aClass.ePackage.isEcorePackage() then 'ecore.' else '' endif]
[let aPackage : EPackage = aClass.ePackage ]
test("set[aStructuralFeature.name.toUpperFirst()/]", () => {
	let o = new [aClass.getImplementationName()/]();
	[aStructuralFeature.eType.generateTestValue(aPackage,'value')/]

	// add listener
	let mockAdapter = mock<[ecorePrefix/]EAdapter>();
	let adapter = instance(mockAdapter);
	o.eAdapters.add(adapter);

	// set value
	o.[aStructuralFeature.getPropertyName()/] = value;

	// checks
	verify(mockAdapter.notifyChanged(anything())).once();
	const ['['/]notification[']'/] = capture(mockAdapter.notifyChanged).last();
	expect(notification.notifier).toBe(o)
[let defaultValue : String = aStructuralFeature.getDefaultValue(aClass)]
[if defaultValue = 'null']
	expect(notification.oldValue).toBeNull();
[else]
	expect(notification.oldValue).toBe([defaultValue/]);
[/if]
[/let]
	expect(notification.newValue).toBe(value);
	expect(notification.position).toBe(-1);
})
[/let]
[/let]
[/template]


[template private generateBasicSetTestImplementation(aStructuralFeature : EStructuralFeature,aClass : EClass)]
[let ecorePrefix : String = if not aClass.ePackage.isEcorePackage() then 'ecore.' else '' endif]
[let aPackage : EPackage = aClass.ePackage ]
test("basicSet[aStructuralFeature.name.toUpperFirst()/]", () => {
	let o = new [aClass.getImplementationName()/]();
	[aStructuralFeature.eType.generateTestValue(aPackage,'value')/]

	// add listener
	let mockAdapter = mock<[ecorePrefix/]EAdapter>();
	let adapter = instance(mockAdapter);
	o.eAdapters.add(adapter);

	// notification chain
	let mockNotifications = mock<[ecorePrefix/]ENotificationChain>();
	let notifications = instance(mockNotifications);

	// set value
[if isContainer()]
	when(mockValue.eResource()).thenReturn(null)
[/if]
	when(mockNotifications.add(anything())).thenReturn(true)
	o.basicSet[aStructuralFeature.getPropertyName().toUpperFirst()/](value,notifications);

	// checks
	verify(mockNotifications.add(anything())).once();
	const ['['/]notification[']'/] = capture(mockNotifications.add).last();
	expect(notification.notifier).toBe(o)
	expect(notification.eventType).toBe([ecorePrefix/]EventType.SET);
	expect(notification.featureID).toBe([aClass.getQualifiedIDName(aStructuralFeature)/]);
[let defaultValue : String = aStructuralFeature.getDefaultValue(aClass)]
[if defaultValue = 'null']
	expect(notification.oldValue).toBeNull();
[else]
	expect(notification.oldValue).toBe([defaultValue/]);
[/if]
[/let]
	expect(notification.newValue).toBe(value);
	expect(notification.position).toBe(-1);
})
[/let]
[/let]
[/template]

[template private generateUnSetTestImplementation(aStructuralFeature : EStructuralFeature,aClass : EClass) ?(isVolatile())]
test("unset[aStructuralFeature.name.toUpperFirst()/]", () => {
	let o = new [aClass.getImplementationName()/]();
	expect(() => o.[aStructuralFeature.getUnSetterName()/]()).toThrow(Error);
})
[/template]

[template private generateUnSetTestImplementation(aStructuralFeature : EStructuralFeature,aClass : EClass) ?(isListType())]
test("unset[aStructuralFeature.name.toUpperFirst()/]", () => {
	let o = new [aClass.getImplementationName()/]();
	o.[aStructuralFeature.getUnSetterName()/]();
	expect(o.[aStructuralFeature.getPropertyName()/].isEmpty()).toBeTruthy();
})
[/template]

[template private generateUnSetTestImplementation(aStructuralFeature : EStructuralFeature,aClass : EClass)]
[let ecorePrefix : String = if not aClass.ePackage.isEcorePackage() then 'ecore.' else '' endif]
test("unset[aStructuralFeature.name.toUpperFirst()/]", () => {
	let o = new [aClass.getImplementationName()/]();
	
	// add listener
	let mockAdapter = mock<[ecorePrefix/]EAdapter>();
	let adapter = instance(mockAdapter);
	o.eAdapters.add(adapter);

	// unset
	o.[aStructuralFeature.getUnSetterName()/]();

	// checks
	verify(mockAdapter.notifyChanged(anything())).once();
	const ['['/]notification[']'/] = capture(mockAdapter.notifyChanged).last();
	expect(notification.notifier).toBe(o)
	expect(notification.eventType).toBe([ecorePrefix/]EventType.UNSET);
	expect(notification.featureID).toBe([aClass.getQualifiedIDName(aStructuralFeature)/]);	
[let defaultValue : String = aStructuralFeature.getDefaultValue(aClass)]
[if defaultValue = 'null']
	expect(o.[aStructuralFeature.getPropertyName()/]).toBeNull();
[else]
	expect(o.[aStructuralFeature.getPropertyName()/]).toBe([defaultValue/]);
[/if]
[/let]
})
[/let]
[/template]


[template private generateTestValue(aClass : EClass, aPackage : EPackage , varname : String )]
let mock[varname.toUpperFirst()/] = mock<[aClass.getInterfaceName()/]Internal>();
let [varname/] = instance(mock[varname.toUpperFirst()/]);
[/template]

[template private generateTestValue(aDataType : EDataType, aPackage : EPackage , varname : String)]
let [varname/] = [aDataType.getTestValue(aPackage)/];
[/template]

[template private generateTestValue(aEEnum : EEnum, aPackage : EPackage , varname : String)]
let [varname/] = [aEEnum.getTestValue(aPackage)/];
[/template]

[template private generateTestValue(aClassifier : EClassifier, aPackage : EPackage , varname : String )]
let [varname/] = null
[/template]

[template private generateTestOperation(anEOperation : EOperation, aClass : EClass )]
test("[anEOperation.getOperationName()/]", () => {
	let o = new([aClass.getImplementationName()/])
	expect(() => o.[anEOperation.getOperationName()/]([for (eClassifier : EClassifier | anEOperation.eParameters.eType) separator(',')][eClassifier.getDefaultValue(aClass)/][/for])).toThrow(Error);
})

[/template]

[template private generateElementIDTestImplementation(aClass : EClass)]
[let ecorePrefix : String = if not aClass.ePackage.isEcorePackage() then 'ecore.' else '' endif]
[let mixinClasses : Set(EClass) = aClass.getMixinClasses()]
[if mixinClasses->exists( c : EClass | c.getImplementedFeatures()->notEmpty())]
test("eDerivedFeatureID", () => {
	let o = new [aClass.getImplementationName()/]();
	{
		let mockClass = mock<[ecorePrefix/]EClass>();
		let cls = instance(mockClass);
		expect(o.eDerivedFeatureID(cls,1)).toBe(1);
	}
[for (aMixinClass : EClass | mixinClasses)]
	{
		let cls = get[aClass.ePackage.getInterfaceName()/]().get[aMixinClass.getElementAccessorName()/]();
		expect(o.eDerivedFeatureID(cls,-1)).toBe(-1);
	[for (aFeature : EStructuralFeature | aMixinClass.getImplementedFeatures() )]
		expect(o.eDerivedFeatureID(cls,[aMixinClass.getQualifiedIDName(aFeature)/])).toBe([aClass.getQualifiedIDName(aFeature)/]);
	[/for]
	}
[/for]
})
[/if]

[if mixinClasses->exists( c : EClass | c.getImplementedOperations()->notEmpty())]
test("eDerivedOperationID", () => {
	let o = new [aClass.getImplementationName()/]();
	{
		let mockClass = mock<[ecorePrefix/]EClass>();
		let cls = instance(mockClass);
		expect(o.eDerivedOperationID(cls,1)).toBe(1);
	}
[for (aMixinClass : EClass | mixinClasses)]
	{
		let cls = get[aClass.ePackage.getInterfaceName()/]().get[aMixinClass.getElementAccessorName()/]();
		expect(o.eDerivedOperationID(cls,-1)).toBe(-1);
	[for (aOperation : EOperation | aMixinClass.getImplementedOperations() )]
		expect(o.eDerivedOperationID(cls,[aMixinClass.getQualifiedIDName(aOperation)/])).toBe([aClass.getQualifiedIDName(aOperation)/]);
	[/for]
	}
[/for]
})
[/if]
[/let]
[/let]
[/template]

[template private generateEGetFromIDTestImplementation(aClass : EClass)]
[let ecorePrefix : String = if not aClass.ePackage.isEcorePackage() then 'ecore.' else '' endif]
[let features : OrderedSet(EStructuralFeature) = aClass.getEGetFeatures()->asOrderedSet()->sortedBy(name)]
[if features->notEmpty()]
test("eGetFromID", () => {
	let o = new [aClass.getImplementationName()/]();
	expect(() => o.eGetFromID(-1,true)).toThrow(Error);
	[for (anStructFeature : EStructuralFeature | features )]
	[if anStructFeature.isVolatile() or ( anStructFeature.hasInitializationMethod() and anStructFeature.oclIsKindOf(EReference) and not anStructFeature.isListType() and not anStructFeature.isProxy() )  ]
	expect(() => o.eGetFromID([aClass.getQualifiedIDName(anStructFeature)/],true)).toThrow(Error);
	expect(() => o.eGetFromID([aClass.getQualifiedIDName(anStructFeature)/],false)).toThrow(Error);
	[else]
	expect(o.eGetFromID([aClass.getQualifiedIDName(anStructFeature)/],true)).toStrictEqual(o.[anStructFeature.getPropertyName()/]);
	[if (not anStructFeature.isMapType() and anStructFeature.isListType() and anStructFeature.oclIsKindOf(EReference))]
	expect(
		deepEqual(
			o.eGetFromID([aClass.getQualifiedIDName(anStructFeature)/],false),
			(o.[anStructFeature.getPropertyName()/] as [ecorePrefix/]EObjectList<[anStructFeature.eGenericType.generateListTypeParameters(aClass.ePackage)/]>).getUnResolvedList()
		)
	).toBeTruthy();
	[/if]
	[/if]
    [/for]
})
[/if]
[/let]
[/let]
[/template]

[template private generateFeatureESetFromIDTestImplementation(anStructuralFeature : EStructuralFeature ,aClass : EClass) ? (isVolatile())]
expect(() => o.eSetFromID([aClass.getQualifiedIDName(anStructuralFeature)/],null)).toThrow(Error);

[/template]

[template private generateFeatureESetFromIDTestImplementation(anStructuralFeature : EStructuralFeature ,aClass : EClass) ? (isContainer())]
{
[let reverseFeature : EStructuralFeature = anStructuralFeature.oclAsType(EReference).eOpposite]
[let reverseClass : EClass = reverseFeature.eContainingClass]
	[anStructuralFeature.eType.generateTestValue(aClass.ePackage,'value')/]
	when(mockValue.eIsProxy()).thenReturn(false);
	when(mockValue.eResource()).thenReturn(null);
	when(mockValue.eInverseAdd(o,[reverseClass.getQualifiedIDName(reverseFeature)/],null)).thenReturn(null);
	o.eSetFromID([aClass.getQualifiedIDName(anStructuralFeature)/], value);
	expect(o.eGetFromID([aClass.getQualifiedIDName(anStructuralFeature)/], false)).toBe(value);
	verify(mockValue.eIsProxy()).once();
	verify(mockValue.eResource()).once();
	verify(mockValue.eInverseAdd(o,[reverseClass.getQualifiedIDName(reverseFeature)/],null)).once();
[/let]
[/let]	
}

[/template]

[template private generateFeatureESetFromIDTestImplementation(anStructuralFeature : EStructuralFeature ,aClass : EClass) ? (isMapType() and anStructuralFeature.eType.oclIsKindOf(EClass) and anStructuralFeature.eType.oclAsType(EClass).isMapEntry())]
{
[let aPackage : EPackage = aClass.ePackage]
[let ecorePrefix : String = if not aPackage.isEcorePackage() then 'ecore.' else '' endif]
[let aMapClass : EClass = anStructuralFeature.eType.oclAsType(EClass)]
[let keyFeature : EStructuralFeature = aMapClass.getEStructuralFeature('key')]
[let valueFeature : EStructuralFeature = aMapClass.getEStructuralFeature('value')]
	let mockMap = mock<[ecorePrefix/]EMap<[anStructuralFeature.eGenericType.generateMapTypeParameters(aPackage)/]>>();
	let map = instance(mockMap);
	let mockIterator = mock<Iterator<[ecorePrefix/]EMapEntry<[anStructuralFeature.eGenericType.generateMapTypeParameters(aPackage)/]>>>();
	let iterator = instance(mockIterator);
	let mockEntry = mock<[ecorePrefix/]EMapEntry<[anStructuralFeature.eGenericType.generateMapTypeParameters(aPackage)/]>>();
	let entry = instance(mockEntry);
	[keyFeature.eType.generateTestValue(aPackage,'key')/]
	[valueFeature.eType.generateTestValue(aPackage,'value')/]
	when(mockMap['['/]Symbol.iterator[']'/]()).thenReturn(iterator);
	when(mockIterator.next()).thenReturn({ value: entry, done: false } ).thenReturn({ value: undefined, done: true });
	when(mockEntry.key).thenReturn(key);
	when(mockEntry.value).thenReturn(value);
	o.eSetFromID([aClass.getQualifiedIDName(anStructuralFeature)/], map);
	expect(o.[anStructuralFeature.getPropertyName()/].toMap()).toEqual(new Map<[anStructuralFeature.eGenericType.generateMapTypeParameters(aPackage)/]>(['['/]['['/]key,value[']'/][']'/]));
[/let]
[/let]
[/let]
[/let]
[/let]
}

[/template]

[template private generateFeatureESetFromIDTestImplementation(anStructuralFeature : EStructuralFeature ,aClass : EClass) ? (isMapType())]
[/template]

[template private generateFeatureESetFromIDTestImplementation(anStructuralFeature : EStructuralFeature ,aClass : EClass) ? (isListType() and oclIsKindOf(EReference))]
[let ecorePrefix : String = if not aClass.ePackage.isEcorePackage() then 'ecore.' else '' endif]
{
	// list with a value
	[anStructuralFeature.eType.generateTestValue(aClass.ePackage,'value')/]
	let l = new [ecorePrefix/]ImmutableEList<[anStructuralFeature.eGenericType.generateListTypeParameters(aClass.ePackage)/]>(['['/]value[']'/]);
[if anStructuralFeature.isProxy()]
	when(mockValue.eIsProxy()).thenReturn(false);
[/if]
	[anStructuralFeature.generateFeatureMockAddedExpectations('mockValue',aClass)/]
	// set list with new contents
	o.eSetFromID([aClass.getQualifiedIDName(anStructuralFeature)/], l);
	// checks
	expect(o.[anStructuralFeature.getPropertyName()/].size()).toBe(1);
	expect(o.[anStructuralFeature.getPropertyName()/].get(0)).toBe(value);
	[anStructuralFeature.generateFeatureMockAddedVerifications('mockValue',aClass)/]
}

[/let]
[/template]

[template private generateFeatureMockAddedExpectations(anStructuralFeature : EStructuralFeature , mockName : String , aClass : EClass)]
[if anStructuralFeature.isContains()]
	[let anEReference : EReference = anStructuralFeature.oclAsType(EReference)]
	[if anEReference.eOpposite.oclIsUndefined()]
when([mockName/].eInverseAdd(o,[if not aClass.ePackage.isEcorePackage()]ecore.[/if]EOPPOSITE_FEATURE_BASE - [aClass.getQualifiedIDName(anStructuralFeature)/],anything())).thenReturn(null);
	[else]
	[let reverseFeature : EStructuralFeature = anStructuralFeature.oclAsType(EReference).eOpposite]
	[let reverseClass : EClass = reverseFeature.eContainingClass]
when([mockName/].eInverseAdd(o,[reverseClass.getQualifiedIDName(reverseFeature)/],anything())).thenReturn(null); 
	[/let]
	[/let]
	[/if]
	[/let]
[elseif anStructuralFeature.oclIsKindOf(EReference)]
	[let anEReference : EReference = anStructuralFeature.oclAsType(EReference)]
	[if anEReference.eOpposite.oclIsUndefined()]
	[else]
	[let reverseFeature : EStructuralFeature = anStructuralFeature.oclAsType(EReference).eOpposite]
	[let reverseClass : EClass = reverseFeature.eContainingClass]
when([mockName/].eInverseAdd(o,[reverseClass.getQualifiedIDName(reverseFeature)/],anything())).thenReturn(null); 
	[/let]
	[/let]
	[/if]
	[/let]
[/if]
[/template]


[template private generateFeatureMockAddedVerifications(anStructuralFeature : EStructuralFeature , mockName : String , aClass : EClass)]
[if anStructuralFeature.isContains()]
	[let anEReference : EReference = anStructuralFeature.oclAsType(EReference)]
	[if anEReference.eOpposite.oclIsUndefined()]
verify([mockName/].eInverseAdd(o,[if not aClass.ePackage.isEcorePackage()]ecore.[/if]EOPPOSITE_FEATURE_BASE - [aClass.getQualifiedIDName(anStructuralFeature)/],anything())).once();
	[else]
	[let reverseFeature : EStructuralFeature = anStructuralFeature.oclAsType(EReference).eOpposite]
	[let reverseClass : EClass = reverseFeature.eContainingClass]
verify([mockName/].eInverseAdd(o,[reverseClass.getQualifiedIDName(reverseFeature)/],anything())).once();
	[/let]
	[/let]
	[/if]
	[/let]
[elseif anStructuralFeature.oclIsKindOf(EReference)]
	[let anEReference : EReference = anStructuralFeature.oclAsType(EReference)]
	[if anEReference.eOpposite.oclIsUndefined()]
	[else]
	[let reverseFeature : EStructuralFeature = anStructuralFeature.oclAsType(EReference).eOpposite]
	[let reverseClass : EClass = reverseFeature.eContainingClass]
verify([mockName/].eInverseAdd(o,[reverseClass.getQualifiedIDName(reverseFeature)/],anything())).once();
	[/let]
	[/let]
	[/if]
	[/let]
[/if]
[/template]

[template private generateFeatureESetFromIDTestImplementation(anStructuralFeature : EStructuralFeature ,aClass : EClass) ? (isListType())]
[let ecorePrefix : String = if not aClass.ePackage.isEcorePackage() then 'ecore.' else '' endif]
{
	let l = new [ecorePrefix/]ImmutableEList<[anStructuralFeature.eGenericType.generateListTypeParameters(aClass.ePackage)/]>();
	o.eSetFromID([aClass.getQualifiedIDName(anStructuralFeature)/], l)
	expect(o.[anStructuralFeature.getPropertyName()/].isEmpty()).toBeTruthy();
}
[/let]

[/template]

[template private generateFeatureESetFromIDTestImplementation(anStructuralFeature : EStructuralFeature ,aClass : EClass) ? (isBidirectional())]
{
[let reverseFeature : EStructuralFeature = anStructuralFeature.oclAsType(EReference).eOpposite]
[let reverseClass : EClass = reverseFeature.eContainingClass]
	[anStructuralFeature.eType.generateTestValue(aClass.ePackage,'value')/]
	when(mockValue.eInverseAdd(o,[reverseClass.getQualifiedIDName(reverseFeature)/],null)).thenReturn(null);	
	o.eSetFromID([aClass.getQualifiedIDName(anStructuralFeature)/], value);
	expect(o.eGetFromID([aClass.getQualifiedIDName(anStructuralFeature)/], false)).toBe(value);
	verify(mockValue.eInverseAdd(o,[reverseClass.getQualifiedIDName(reverseFeature)/],null)).once();
[/let]
[/let]
}

[/template]

[template private generateFeatureESetFromIDTestImplementation(anStructuralFeature : EStructuralFeature ,aClass : EClass) ? (isContains())]
{
	[anStructuralFeature.eType.generateTestValue(aClass.ePackage,'value')/]
	when(mockValue.eInverseAdd(o,[if not aClass.ePackage.isEcorePackage()]ecore.[/if]EOPPOSITE_FEATURE_BASE - [aClass.getQualifiedIDName(anStructuralFeature)/],anything())).thenReturn(null);
	o.eSetFromID([aClass.getQualifiedIDName(anStructuralFeature)/], value);
	expect(o.eGetFromID([aClass.getQualifiedIDName(anStructuralFeature)/], false)).toBe(value);
	verify(mockValue.eInverseAdd(o,[if not aClass.ePackage.isEcorePackage()]ecore.[/if]EOPPOSITE_FEATURE_BASE - [aClass.getQualifiedIDName(anStructuralFeature)/],anything())).once();
}

[/template]

[template private generateFeatureESetFromIDTestImplementation(anStructuralFeature : EStructuralFeature ,aClass : EClass)]
{
	[anStructuralFeature.eType.generateTestValue(aClass.ePackage,'value')/]	
	o.eSetFromID([aClass.getQualifiedIDName(anStructuralFeature)/], value);
	expect(o.eGetFromID([aClass.getQualifiedIDName(anStructuralFeature)/], false)).toBe(value);
}

[/template]

[template private generateESetFromIDTestImplementation(aClass : EClass)]
[let aPackage : EPackage = aClass.ePackage ]
[let features : OrderedSet(EStructuralFeature) = aClass.getESetFeatures()->select(not isFeatureMap())->asOrderedSet()->sortedBy(name)]
[if features->notEmpty()]
test("eSetFromID", () => {
	let o = new [aClass.getImplementationName()/]();
	expect(() => o.eSetFromID(-1,null)).toThrow(Error);
	[features.generateFeatureESetFromIDTestImplementation(aClass)/]
})
[/if]
[/let]
[/let]
[/template]

[template private generateEIsSetFromIDTestImplementation(aClass : EClass)]
[let features : OrderedSet(EStructuralFeature) = aClass.getEIsSetFeatures()->select(not isFeatureMap())->asOrderedSet()->sortedBy(name)]
[if features->notEmpty()]
test("eIsSetFromID", () => {
	let o = new [aClass.getImplementationName()/]();
	expect(() => o.eIsSetFromID(-1)).toThrow(Error);
	[for (anStructFeature : EStructuralFeature | features)]
		[if anStructFeature.isVolatile()]
		expect(() => o.eIsSetFromID([aClass.getQualifiedIDName(anStructFeature)/])).toThrow(Error);
		[else]
		expect(o.eIsSetFromID([aClass.getQualifiedIDName(anStructFeature)/])).toBeFalsy();
		[/if]		
	[/for]
})
[/if]
[/let]
[/template]


[template private generateEUnSetFromIDTestImplementation(aClass : EClass)]
[let features : OrderedSet(EStructuralFeature) = aClass.getEUnSetFeatures()->select(not isFeatureMap())->asOrderedSet()->sortedBy(name)]
[if features->notEmpty()]
test("eUnsetFromID", () => {
	let o = new [aClass.getImplementationName()/]();
	expect(() => o.eUnsetFromID(-1)).toThrow(Error);
	[for (anStructFeature : EStructuralFeature | features)]
	{
	[if anStructFeature.isVolatile()]
		expect(() => o.eUnsetFromID([aClass.getQualifiedIDName(anStructFeature)/])).toThrow(Error);
	[else]
		o.eUnsetFromID([aClass.getQualifiedIDName(anStructFeature)/]);
		[if anStructFeature.isListType()]
		let v = o.eGetFromID([aClass.getQualifiedIDName(anStructFeature)/], false);
		expect(v).not.toBeNull();
		let l = v as [if not aClass.ePackage.isEcorePackage()]ecore.[/if]EList<[anStructFeature.eGenericType.generateListTypeParameters(aClass.ePackage)/]>; 
		expect(l.isEmpty()).toBeTruthy();
		[elseif anStructFeature.oclIsKindOf(EReference)]
		expect(o.eGetFromID([aClass.getQualifiedIDName(anStructFeature)/], false)).toBeNull();
		[else]
			[let aAttribute : EAttribute = anStructFeature.oclAsType(EAttribute)]
			[let defaultValue : String = aAttribute.getDefaultValue(aClass)]
			[if defaultValue <> '']
		let v = o.eGetFromID([aClass.getQualifiedIDName(anStructFeature)/], false);
			[if defaultValue = 'nil']
		expect(v).toBeNull();
			[else]
		expect(v).toBe([defaultValue/]);
			[/if]	
			[else]
			[/if]
			[/let]
			[/let]
		[/if]
	[/if]
	}
	[/for]
})
[/if]
[/let]
[/template]

[template private generateEInverseAddTestImplementation(aClass : EClass)]
[let ecorePrefix : String = if not aClass.ePackage.isEcorePackage() then 'ecore.' else '' endif]
[let features : OrderedSet(EStructuralFeature) = aClass.getEInverseAddFeatures()->asOrderedSet()->sortedBy(name)]
[if features->notEmpty()]
test("eBasicInverseAdd", () => {
	let o = new [aClass.getImplementationName()/]();
	{
		let mockObject = mock<[ecorePrefix/]EObject>();
		let object = instance(mockObject);
		let mockNotifications = mock<[ecorePrefix/]ENotificationChain>(); 
		let notifications = instance(mockNotifications);
		expect(o.eBasicInverseAdd(object,-1,notifications)).toBe(notifications);
	}
	[features.generateFeatureEInverseAddTestImplementation(aClass)/]
})
[/if]
[/let]
[/let]
[/template]

[template private generateFeatureEInverseAddTestImplementation( aStructuralFeature : EStructuralFeature, aClass : EClass ) ?(isMapType())]
[/template]

[template private generateFeatureEInverseAddTestImplementation( aStructuralFeature : EStructuralFeature, aClass : EClass ) ?(isListType())]
{
	[aStructuralFeature.eType.generateTestValue(aClass.ePackage,'value')/]
	o.eBasicInverseAdd(value,[aClass.getQualifiedIDName(aStructuralFeature)/],null);
	expect(o.[aStructuralFeature.getPropertyName()/].contains(value)).toBeTruthy();
}

[/template]

[template private generateFeatureEInverseAddTestImplementation( aStructuralFeature : EStructuralFeature, aClass : EClass ) ?(isContainer())]
{
	[aStructuralFeature.eType.generateTestValue(aClass.ePackage,'value')/]
	when(mockValue.eResource()).thenReturn(null);
	when(mockValue.eIsProxy()).thenReturn(false);
	o.eBasicInverseAdd(value,[aClass.getQualifiedIDName(aStructuralFeature)/],null);
	expect(o.[aStructuralFeature.getPropertyName()/]).toBe(value);

	reset(mockValue);
	[aStructuralFeature.eType.generateTestValue(aClass.ePackage,'other')/]
	when(mockOther.eResource()).thenReturn(null);
	when(mockOther.eIsProxy()).thenReturn(false);
	when(mockValue.eResource()).thenReturn(null);
[if aStructuralFeature.isContains()]
	when(mockValue.eInverseRemove(o,[if not aClass.ePackage.isEcorePackage()]ecore.[/if]EOPPOSITE_FEATURE_BASE - [aClass.getQualifiedIDName(aStructuralFeature)/],null)).thenReturn(null);
[else]
	[let reverseFeature : EStructuralFeature = aStructuralFeature.oclAsType(EReference).eOpposite]
	when(mockValue.eInverseRemove(o,[reverseFeature.eContainingClass.getQualifiedIDName(reverseFeature)/],null)).thenReturn(null);
	[/let]
[/if]
	o.eBasicInverseAdd(other,[aClass.getQualifiedIDName(aStructuralFeature)/],null);
	expect(o.[aStructuralFeature.getPropertyName()/]).toBe(other);
}

[/template]

[template private generateFeatureEInverseAddTestImplementation( aStructuralFeature : EStructuralFeature, aClass : EClass )]
{
	[aStructuralFeature.eType.generateTestValue(aClass.ePackage,'value')/]
[if aStructuralFeature.isProxy()]
	when(mockValue.eIsProxy()).thenReturn(false);
[/if]
	o.eBasicInverseAdd(value,[aClass.getQualifiedIDName(aStructuralFeature)/],null);
	expect(o.[aStructuralFeature.getPropertyName()/]).toBe(value);

	reset(mockValue);
	[aStructuralFeature.eType.generateTestValue(aClass.ePackage,'other')/]
[if aStructuralFeature.isProxy()]
	when(mockOther.eIsProxy()).thenReturn(false);
[/if]
[if aStructuralFeature.isContains()]
	when(mockValue.eInverseRemove(o,[if not aClass.ePackage.isEcorePackage()]ecore.[/if]EOPPOSITE_FEATURE_BASE - [aClass.getQualifiedIDName(aStructuralFeature)/],null)).thenReturn(null);
[else]
	[let reverseFeature : EStructuralFeature = aStructuralFeature.oclAsType(EReference).eOpposite]
	when(mockValue.eInverseRemove(o,[reverseFeature.eContainingClass.getQualifiedIDName(reverseFeature)/],null)).thenReturn(null);
	[/let]
[/if]
	o.eBasicInverseAdd(other,[aClass.getQualifiedIDName(aStructuralFeature)/],null);
	expect(o.[aStructuralFeature.getPropertyName()/]).toBe(other);
}

[/template]


[template private generateEInverseRemoveTestImplementation(aClass : EClass)]
[let ecorePrefix : String = if not aClass.ePackage.isEcorePackage() then 'ecore.' else '' endif]
[let features : OrderedSet(EStructuralFeature) = aClass.getEInverseRemoveFeatures()->asOrderedSet()->sortedBy(name)]
[if features->notEmpty()]
test("eBasicInverseRemove", () => {
	let o = new [aClass.getImplementationName()/]();
	{
		let mockObject = mock<[ecorePrefix/]EObject>();
		let object = instance(mockObject);
		let mockNotifications = mock<[ecorePrefix/]ENotificationChain>(); 
		let notifications = instance(mockNotifications);
		expect(o.eBasicInverseRemove(object,-1,notifications)).toBe(notifications);
	}
	[features.generateFeatureEInverseRemoveTestImplementation(aClass)/]
})
[/if]
[/let]
[/let]
[/template]

[template private generateFeatureEInverseRemoveTestImplementation( aStructuralFeature : EStructuralFeature, aClass : EClass ) ?(isMapType())]
{
	[aStructuralFeature.eType.generateTestValue(aClass.ePackage,'value')/]
	o.eBasicInverseRemove(mockValue,[aClass.getQualifiedIDName(aStructuralFeature)/],null);
	expect(o.[aStructuralFeature.getPropertyName()/].isEmpty())
}

[/template]

[template private generateFeatureEInverseRemoveTestImplementation( aStructuralFeature : EStructuralFeature, aClass : EClass ) ?(isListType())]
{
	// initialize list with a mock object
	[aStructuralFeature.eType.generateTestValue(aClass.ePackage,'value')/]
	[aStructuralFeature.generateFeatureMockAddedExpectations('mockValue',aClass)/]
	o.[aStructuralFeature.getPropertyName()/].add(value);

	// basic inverse remove
	o.eBasicInverseRemove(value,[aClass.getQualifiedIDName(aStructuralFeature)/],null);

	// check it was removed
	expect(o.[aStructuralFeature.getPropertyName()/].contains(value)).toBeFalsy();
}

[/template]

[template private generateFeatureEInverseRemoveTestImplementation( aStructuralFeature : EStructuralFeature, aClass : EClass )]
{
	[aStructuralFeature.eType.generateTestValue(aClass.ePackage,'value')/]
	o.eBasicInverseRemove(value,[aClass.getQualifiedIDName(aStructuralFeature)/],null);	
}

[/template]

[template private generateEInvokeFromIDTestImplementation(aClass : EClass)]
[let operations : OrderedSet(EOperation) = aClass.getEInvokeOperations()->asOrderedSet()->sortedBy( o | o.eContainingClass.getOperationIDName(o))]
[if aClass.name <> 'EObject' and operations->notEmpty()]
test("eInvokeFromID", () => {
	let o = new [aClass.getImplementationName()/]();
	expect(() => o.eInvokeFromID(-1,null)).toThrow(Error);
	[for ( eOperation : EOperation | operations )]
	expect(() => o.eInvokeFromID([eOperation.eContainingClass.getQualifiedIDName(eOperation)/],null)).toThrow(Error);
	[/for]
})
[/if]
[/let]
[/template]




