[**
 * This file is part of soft.generator.ts, a project for typescript 
 * code generation of an ecore model
 *
 * Copyright(c) 2021 MASA Group
 *	
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
**/]

[comment encoding = UTF-8 /]
[module generateImplementationTests('http://www.eclipse.org/emf/2002/Ecore')/]


[import soft::generator::common::generateCommon/]
[import soft::generator::common::generateElement/]
[import soft::generator::common::generateStructuralFeature/]
[import soft::generator::ts::generateCommon /]
[import soft::generator::ts::generateElement /]
[import soft::generator::ts::generateType /]
[import soft::generator::ts::lib::generateCommon /]
[import soft::generator::ts::lib::generateReflectives /]

[template public generateImplementationTests(aClass : EClass) { 
	aPackage : EPackage = aClass.ePackage;
	className : String = aClass.getImplementationName();
	features : Collection(EStructuralFeature) = aClass.getImplementedFeatures()->sortedBy( getVariableName() );
}]
[file (aClass.ePackage.getOutputDirectory() + '/' + aClass.getImplementationTestFileName( aClass.name ), false, 'UTF-8')]
[fileComment()/]

[comment imports/]
import { anything , capture, instance, mock, verify, when } from "ts-mockito";
[let allTypes : OrderedSet(String) = Set{ aClass.getReferencedTypes()->collect( cls | cls.getType() )->asSet()
                                        , if aClass.requiresMap() then Set{ 'ecore.EMap', 'ecore.BasicEObjectMap', 'ecore.EMapEntry' } else Set{} endif
                                        , if aClass.requiresList() then Set{ 'ecore.EList', 'ecore.BasicEList', 'ecore.BasicEObjectList', aPackage.getQualifiedConstantsName() } else Set{} endif
                                        , if aClass.hasReflectives() then Set{'ecore.EObject','ecore.EObjectInternal','ecore.EList','ecore.ENotifyingList','ecore.ENotificationChain','ecore.isEObjectList'} else Set{} endif
                                        , if features->exists(requiresNotification()) then Set{'ecore.ENotification','ecore.ENotificationChain','ecore.EventType','ecore.Notification','ecore.EOPPOSITE_FEATURE_BASE', aPackage.getQualifiedConstantsName() } else Set{} endif
                                        , if features->exists(isContainer()) then Set{aPackage.getQualifiedConstantsName()} else Set{} endif
                                        , Set {aClass.getQualifiedImplementationName(), aPackage.name + '.' + 'get'+ aPackage.getInterfaceName()}
                                        , Set {'ecore.EResource', 'ecore.EResourceSet', 'ecore.EAdapter'}
                                        }->flatten()->select(s | s <> '')->asOrderedSet()->sortedBy(s | s)]
[aPackage.generateImports(allTypes,aClass.getImplementationTestFileName( aClass.name ))/]
[/let]

[comment mock types defined in get/set methods/]
[let ecorePrefix : String = if not aClass.ePackage.isEcorePackage() then 'ecore.' else '' endif]
[let mockTypes : OrderedSet(EClass) = features->select(oclIsKindOf(EReference) and isProxy() and eType.oclIsKindOf(EClass) and eType.name <> 'EObject')
											  ->collect(eType.oclAsType(EClass))->asOrderedSet()->sortedBy(name)]
[for (mockType: EClass | mockTypes)]
interface [mockType.getInterfaceName()/]Internal extends [mockType.getInterfaceName()/], [ecorePrefix/]EObjectInternal {} 
[/for]
[/let]
[/let]

describe("[className/]", () => {
	
	test("eStaticClass", () => {
        let cls = new [className/]()
		expect(cls.eStaticClass()).toBe(get[aPackage.getInterfaceName()/]().[aClass.getReflectiveGetterName()/]());
    });

	[aClass.getImplementedFeatures()->sortedBy( getVariableName() ).generateTestFeature(aClass)/]
	[aClass.getImplementedOperations()->sortedBy( getOperationName() )->select(isDefault()).generateTestOperation(aClass)/]

})

[/file]
[/template]


[template private generateTestFeature(aStructuralFeature : EStructuralFeature, aClass : EClass )]
[if isGet()]

[aStructuralFeature.generateGetTestImplementation(aClass)/]
[/if]
[if isSet()]

[aStructuralFeature.generateSetTestImplementation(aClass)/]
[/if]
[/template]

[template private generateGetTestImplementation(aStructuralFeature : EStructuralFeature,aClass : EClass) ? (isVolatile())]
test("get[aStructuralFeature.name.toUpperFirst()/]", () => {
	let cls = new [aClass.getImplementationName()/]()
	expect(() => cls.[aStructuralFeature.getPropertyName()/]).toThrow(Error);
})
[/template]

[template private generateGetTestImplementation(aStructuralFeature : EStructuralFeature,aClass : EClass) ? (isContainer())]
[let ecorePrefix : String = if not aClass.ePackage.isEcorePackage() then 'ecore.' else '' endif]
test("get[aStructuralFeature.name.toUpperFirst()/]", () => {
	// default
	let cls = new [aClass.getImplementationName()/]();
	expect(cls.[aStructuralFeature.getPropertyName()/]).toBeNull();

	// set a mock container
	let mockContainer = mock<[ecorePrefix/]EObject>();
	let container = instance(mockContainer)
	cls.eSetInternalContainer(container,[aClass.getQualifiedIDName(aStructuralFeature)/]);
	
	// no proxy
	when(mockContainer.eIsProxy()).thenReturn(false);
	expect(cls.[aStructuralFeature.getPropertyName()/]).toBe(container);
	verify(mockContainer.eIsProxy()).once();
})
[/let]
[/template]

[template private generateGetTestImplementation(aStructuralFeature : EStructuralFeature,aClass : EClass) ? (isMapType())]
test("get[aStructuralFeature.name.toUpperFirst()/]", () => {
	let cls = new [aClass.getImplementationName()/]();
	expect(cls.[aStructuralFeature.getPropertyName()/]).not.toBeNull();
})
[/template]

[template private generateGetTestImplementation(aStructuralFeature : EStructuralFeature,aClass : EClass) ? (isListType())]
test("get[aStructuralFeature.name.toUpperFirst()/]", () => {
	let cls = new [aClass.getImplementationName()/]();
	[if aStructuralFeature.eType.name = 'EFeatureMapEntry']
	expect(cls.[aStructuralFeature.getPropertyName()/]).toBeNull();
	[else]
	expect(cls.[aStructuralFeature.getPropertyName()/]).not.toBeNull();
	[/if]
})
[/template]

[template private generateGetTestImplementation(aStructuralFeature : EStructuralFeature,aClass : EClass) ? (oclIsKindOf(EReference) and isLazy())]
test("get[aStructuralFeature.name.toUpperFirst()/]", () => {
	let cls = new [aClass.getImplementationName()/]();
	expect(() => cls.[aStructuralFeature.getPropertyName()/]).toThrow(Error);
})
[/template]

[template private generateGetTestImplementation(aStructuralFeature : EStructuralFeature, aClass : EClass) ? (oclIsKindOf(EReference) and isProxy())]
[let ecorePrefix : String = if not aClass.ePackage.isEcorePackage() then 'ecore.' else '' endif]
[let eRefType : EClass = aStructuralFeature.eType.oclAsType(EClass)]
test("get[aStructuralFeature.name.toUpperFirst()/]", () => {
	let cls = new [aClass.getImplementationName()/]();
	
	// get default value
	expect(cls.[aStructuralFeature.getPropertyName()/]).toBeNull();
	
	// initialize object with a mock value
	let mockValue = mock<[getShortQualifiedName( eRefType.getQualifiedInterfaceName() + 'Internal' , aClass.ePackage.name )/]>();
	let value = instance(mockValue);
	cls.[aStructuralFeature.getPropertyName()/] = value;
	
	// events
	let mockAdapter = mock<[ecorePrefix/]EAdapter>();
	let adapter = instance(mockAdapter);
	cls.eAdapters.add(adapter);
	
	// set object resource
	let mockResourceSet = mock<[ecorePrefix/]EResourceSet>();
	let resourceSet = instance(mockResourceSet);
	let mockResource = mock<[ecorePrefix/]EResource>();
	let resource = instance(mockResource);
	cls.eSetInternalResource(resource);

	// get non resolved value
	when(mockValue.eIsProxy()).thenReturn(false)
	expect(cls.[aStructuralFeature.getPropertyName()/]).toBe(value);
	verify(mockValue.eIsProxy()).once()

	// get a resolved value
	let mockURI = new URL("test:///file.t");
	let mockResolved = mock<[getShortQualifiedName( eRefType.getQualifiedInterfaceName() + 'Internal' , aClass.ePackage.name )/]>();
	let resolved = instance(mockResolved);
	when(mockResolved.eProxyURI()).thenReturn(null)
	when(mockResource.eResourceSet()).thenReturn(resourceSet)
	when(mockResourceSet.getEObject(mockURI,true)).thenReturn(resolved)
	when(mockValue.eIsProxy()).thenReturn(true)
	when(mockValue.eProxyURI()).thenReturn(mockURI)
	expect(cls.[aStructuralFeature.getPropertyName()/]).toBe(resolved);
})
[/let]
[/let]
[/template]

[template private generateGetTestImplementation(aStructuralFeature : EStructuralFeature,aClass : EClass) ? (oclIsKindOf(EReference))]
test("get[aStructuralFeature.name.toUpperFirst()/]", () => {
	let cls = new [aClass.getImplementationName()/]();
	
	// get default value
	expect(cls.[aStructuralFeature.getPropertyName()/]).toBeNull();
})
[/template]

[template private generateGetTestImplementation(aStructuralFeature : EStructuralFeature,aClass : EClass) ? (oclIsKindOf(EAttribute))]
test("get[aStructuralFeature.name.toUpperFirst()/]", () => {
	let cls = new [aClass.getImplementationName()/]();
	// get default value
	[let aAttribute : EAttribute = aStructuralFeature.oclAsType(EAttribute)]
	[let aDefaultValue : String = aAttribute.getDefaultValue(aClass)]
	[if aDefaultValue = '']
	expect(cls.[aStructuralFeature.getPropertyName()/]).toBeNull();
	[else]
	expect(cls.[aStructuralFeature.getPropertyName()/]).toBe([aDefaultValue/]);
	[/if]
	[/let]
	[/let]
})
[/template]


[template private generateGetTestImplementation(aStructuralFeature : EStructuralFeature,aClass : EClass)]
[/template]

[template private generateSetTestImplementation(aStructuralFeature : EStructuralFeature,aClass : EClass)]
[let ecorePrefix : String = if not aClass.ePackage.isEcorePackage() then 'ecore.' else '' endif]
[let aPackage : EPackage = aClass.ePackage ]
test("set[aStructuralFeature.name.toUpperFirst()/]", () => {
	let cls = new [aClass.getImplementationName()/]();
	[aStructuralFeature.eType.generateTestValue(aPackage)/]	
	let mockAdapter = mock<[ecorePrefix/]EAdapter>();
	let adapter = instance(mockAdapter);
	cls.eAdapters.add(adapter);
	cls.[aStructuralFeature.getPropertyName()/] = v;
	verify(mockAdapter.notifyChanged(anything())).once()
	const ['['/]notification[']'/] = capture(mockAdapter.notifyChanged).last()
	expect(notification.notifier).toBe(cls)
[let aDefaultValue : String = aStructuralFeature.eType.getDefaultValue(aClass)]
[if aDefaultValue = '']
	expect(notification.oldValue).toBeNull()
[else]
	expect(notification.oldValue).toBe([defaultValue/])
[/if]
[/let]
	expect(notification.newValue).toBe(v)
	expect(notification.position).toBe(-1)
})
[/let]
[/let]
[/template]

[template private generateTestValue(aClass : EClass, aPackage : EPackage )]
let mockValue = mock<[getShortQualifiedName(aClass.getQualifiedInterfaceName() + 'Internal', aPackage.name)/]>()
let v = instance(mockValue)	
[/template]

[template private generateTestValue(aDataType : EDataType, aPackage : EPackage )]
let v = [aDataType.getTestValue(aPackage)/]	
[/template]

[template private generateTestValue(aEEnum : EEnum, aPackage : EPackage )]
let v = [aEEnum.getTestValue(aPackage)/]	
[/template]

[template private generateTestValue(aClassifier : EClassifier, aPackage : EPackage )]
let v = nil	
[/template]


[template private generateTestOperation(anEOperation : EOperation, aClass : EClass )]
test("[anEOperation.getOperationName()/]", () => {
	let cls = new([aClass.getImplementationName()/])
	expect(() => cls.[anEOperation.getOperationName()/]([for (eClassifier : EClassifier | anEOperation.eParameters.eType) separator(',')][eClassifier.getDefaultValue(aClass)/][/for])).toThrow(Error);
})

[/template]
