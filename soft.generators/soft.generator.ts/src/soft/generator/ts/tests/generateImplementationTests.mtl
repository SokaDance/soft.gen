[**
 * This file is part of soft.generator.ts, a project for typescript 
 * code generation of an ecore model
 *
 * Copyright(c) 2021 MASA Group
 *	
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, value. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
**/]

[comment encoding = UTF-8 /]
[module generateImplementationTests('http://www.eclipse.org/emf/2002/Ecore')/]


[import soft::generator::common::generateCommon/]
[import soft::generator::common::generateElement/]
[import soft::generator::common::generateReflectives/]
[import soft::generator::common::generateStructuralFeature/]
[import soft::generator::common::generateUtils/]
[import soft::generator::ts::generateCommon /]
[import soft::generator::ts::generateElement /]
[import soft::generator::ts::generateType /]
[import soft::generator::ts::lib::generateCommon /]
[import soft::generator::ts::lib::generateStructuralFeature /]
[import soft::generator::ts::lib::generateReflectives /]

[query private isFeatureMap(aStructuralFeature : EStructuralFeature) : Boolean = isListType() and eType.name = 'EFeatureMapEntry'/]


[template public generateImplementationTests(aClass : EClass) {
	ecorePackage : EPackage = getEcorePackage(); 
	aPackage : EPackage = aClass.ePackage;
	className : String = aClass.getImplementationName();
	features : Collection(EStructuralFeature) = aClass.getImplementedFeatures()->sortedBy( getVariableName() );
	types : OrderedSet(String) = Set{ aClass.getReferencedTypes()->collect( cls | cls.getType() )->asSet()
									, Set{	
											if aClass.requiresMap()  then Set{'EMap','EMapEntry'} else Set{} endif,
											if aClass.requiresList() then Set{'EList','EObjectList','ImmutableEList','EOPPOSITE_FEATURE_BASE'} else Set{} endif,
		 									if aClass.hasReflectives() then Set{'EObject','EObjectInternal','EList','ENotifyingList','ENotificationChain','isEObjectList'} else Set{} endif,
											if features->exists(requiresNotification()) then Set{'ENotification','ENotificationChain','EventType','Notification','EOPPOSITE_FEATURE_BASE'} else Set{} endif,
											Set{'EResource','EResourceSet','EAdapter','URI'}
									    }->flatten()->collect(t | ecorePackage.getQualifiedIdentifier(t))->asSet()
									, Set{ 
											aClass.getImplementationName(), 
											aPackage.getConstantsName(),
											'get'+ aPackage.getInterfaceName()
										 }->collect(t | aPackage.getQualifiedIdentifier(t))->asSet()
									}->flatten()->select(s | s <> '')->asOrderedSet()->sortedBy(s | s);
	modules : OclAny = aClass.getModules('implementation-tests',types);
}]
[file (aClass.ePackage.getPackageDirectory() + '/' + aClass.getImplementationTestFileName( aClass.name ), false, 'UTF-8')]
[fileComment()/]

[comment imports/]
[if aPackage.isVitest()]
import { describe, expect, test } from "vitest"
[/if]
[if aClass.requiresList()]
import deepEqual from "deep-equal"
[/if]
import { anything, capture, instance, mock, reset, verify, when } from "ts-mockito"
[aPackage.generateImports('implementation-tests', types, modules)/]	

[comment mock types defined in get/set methods/]
[let ecorePrefix : String = if not aClass.ePackage.isEcorePackage() then 'ecore.' else '' endif]
[let mockTypes : OrderedSet(EClass) = features->select(oclIsKindOf(EReference) and eType.oclIsKindOf(EClass) and eType.name <> 'EObject')
											  ->collect(eType.oclAsType(EClass))->asOrderedSet()->sortedBy(name)]
[for (mockType: EClass | mockTypes)]
interface [mockType.getInterfaceName()/]Internal extends [getImportedIdentifier(mockType.getQualifiedInterfaceIdentifier(),modules)/], [ecorePrefix/]EObjectInternal {}
[/for]
[/let]
[/let]

describe("[className/]", () => {
	test("eStaticClass", () => {
        let o = new [className/]()
		expect(o.eStaticClass()).toBe(get[aPackage.getInterfaceName()/]().[aClass.getReflectiveGetterName()/]())
    })

	[aClass.getImplementedFeatures()->sortedBy( getVariableName() ).generateTestFeature(aClass,modules)/]
	[aClass.getImplementedOperations()->sortedBy( getOperationName() )->select(isDefault()).generateTestOperation(aClass,modules)/]
	[aClass.generateElementIDTestImplementation(modules)/]
	[aClass.generateEGetFromIDTestImplementation(modules)/]
	[aClass.generateESetFromIDTestImplementation(modules)/]
	[aClass.generateEIsSetFromIDTestImplementation(modules)/]
	[aClass.generateEUnSetFromIDTestImplementation(modules)/]
	[aClass.generateEInvokeFromIDTestImplementation(modules)/]
	[aClass.generateEInverseAddTestImplementation(modules)/]
	[aClass.generateEInverseRemoveTestImplementation(modules)/]

})

[/file]
[/template]


[template private generateTestFeature(aStructuralFeature : EStructuralFeature, aClass : EClass , modules : OclAny)]
[if isGet()]

[aStructuralFeature.generateGetTestImplementation(aClass,modules)/]
[/if]
[if isSet()]

[aStructuralFeature.generateSetTestImplementation(aClass,modules)/]
[/if]
[if isBasicSet()]

[aStructuralFeature.generateBasicSetTestImplementation(aClass,modules)/]
[/if]
[if isUnSet() and not isPropertyAccessors()]

[aStructuralFeature.generateUnSetTestImplementation(aClass,modules)/]
[/if]
[/template]

[template private generateGetTestImplementation(aStructuralFeature : EStructuralFeature,aClass : EClass, modules : OclAny) ? (isVolatile())]
test("get[aStructuralFeature.name.toUpperFirst()/]", () => {
	let o = new [aClass.getImplementationName()/]()
	expect(() => o.[aStructuralFeature.generateGetCall()/]).toThrow(Error)
})
[/template]

[template private generateGetTestImplementation(aStructuralFeature : EStructuralFeature,aClass : EClass, modules : OclAny) ? (isContainer())]
[let ecorePrefix : String = if not aClass.ePackage.isEcorePackage() then 'ecore.' else '' endif]
test("get[aStructuralFeature.name.toUpperFirst()/]", () => {
	// default
	let o = new [aClass.getImplementationName()/]()
	expect(o.[aStructuralFeature.generateGetCall()/]).toBeNull()

	// set a mock container
	let mockContainer = mock<[ecorePrefix/]EObject>()
	let container = instance(mockContainer)
	o.eSetInternalContainer(container,[aClass.getImportedIDName(aStructuralFeature,modules)/])
	
	// no proxy
	when(mockContainer.eIsProxy()).thenReturn(false)
	expect(o.[aStructuralFeature.generateGetCall()/]).toBe(container)
	verify(mockContainer.eIsProxy()).once()
})
[/let]
[/template]

[template private generateGetTestImplementation(aStructuralFeature : EStructuralFeature,aClass : EClass, modules : OclAny) ? (isMapType())]
test("get[aStructuralFeature.name.toUpperFirst()/]", () => {
	let o = new [aClass.getImplementationName()/]()
	expect(o.[aStructuralFeature.generateGetCall()/]).not.toBeNull()
})
[/template]

[template private generateGetTestImplementation(aStructuralFeature : EStructuralFeature,aClass : EClass, modules : OclAny) ? (isListType())]
test("get[aStructuralFeature.name.toUpperFirst()/]", () => {
	let o = new [aClass.getImplementationName()/]()
	[if aStructuralFeature.eType.name = 'EFeatureMapEntry']
	expect(o.[aStructuralFeature.generateGetCall()/]).toBeNull()
	[else]
	expect(o.[aStructuralFeature.generateGetCall()/]).not.toBeNull()
	[/if]
})
[/template]

[template private generateGetTestImplementation(aStructuralFeature : EStructuralFeature,aClass : EClass, modules : OclAny) ? (oclIsKindOf(EReference) and isLazy())]
test("get[aStructuralFeature.name.toUpperFirst()/]", () => {
	let o = new [aClass.getImplementationName()/]()
	expect(() => o.[aStructuralFeature.generateGetCall()/]).toThrow(Error)
})
[/template]

[template private generateGetTestImplementation(aStructuralFeature : EStructuralFeature, aClass : EClass, modules : OclAny) ? (oclIsKindOf(EReference) and isProxy())]
[let ecorePrefix : String = if not aClass.ePackage.isEcorePackage() then 'ecore.' else '' endif]
[let eRefType : EClass = aStructuralFeature.eType.oclAsType(EClass)]
test("get[aStructuralFeature.name.toUpperFirst()/]", () => {
	let o = new [aClass.getImplementationName()/]()
	
	// get default value
	expect(o.[aStructuralFeature.generateGetCall()/]).toBeNull()
	
	// initialize object with a mock value
	let mockValue = mock<[getImportedIdentifier( eRefType.getQualifiedInterfaceIdentifier() + 'Internal' , modules )/]>()
	let value = instance(mockValue)
	o.[aStructuralFeature.generateSetCall('value')/]
	
	// events
	let mockAdapter = mock<[ecorePrefix/]EAdapter>()
	let adapter = instance(mockAdapter)
	o.eAdapters().add(adapter)
	
	// set object resource
	let mockResourceSet = mock<[ecorePrefix/]EResourceSet>()
	let resourceSet = instance(mockResourceSet)
	let mockResource = mock<[ecorePrefix/]EResource>()
	let resource = instance(mockResource)
	o.eSetInternalResource(resource)

	// get non resolved value
	when(mockValue.eIsProxy()).thenReturn(false)
	expect(o.[aStructuralFeature.generateGetCall()/]).toBe(value)
	verify(mockValue.eIsProxy()).once()

	// get a resolved value
	let mockURI = new [ecorePrefix/]URI("test:///uri")
	let mockResolved = mock<[getImportedIdentifier( eRefType.getQualifiedInterfaceIdentifier() + 'Internal' , modules )/]>()
	let resolved = instance(mockResolved)
	when(mockResolved.eProxyURI()).thenReturn(null)
	when(mockResource.eResourceSet()).thenReturn(resourceSet)
	when(mockResourceSet.getEObject(mockURI,true)).thenReturn(resolved)
	when(mockValue.eIsProxy()).thenReturn(true)
	when(mockValue.eProxyURI()).thenReturn(mockURI)
	expect(o.[aStructuralFeature.generateGetCall()/]).toBe(resolved)
})
[/let]
[/let]
[/template]

[template private generateGetTestImplementation(aStructuralFeature : EStructuralFeature,aClass : EClass, modules : OclAny) ? (oclIsKindOf(EReference))]
test("get[aStructuralFeature.name.toUpperFirst()/]", () => {
	let o = new [aClass.getImplementationName()/]()
	
	// get default value
	expect(o.[aStructuralFeature.generateGetCall()/]).toBeNull()
})
[/template]

[template private generateGetTestImplementation(aStructuralFeature : EStructuralFeature,aClass : EClass, modules : OclAny) ? (oclIsKindOf(EAttribute))]
test("get[aStructuralFeature.name.toUpperFirst()/]", () => {
	let o = new [aClass.getImplementationName()/]()
	// get default value
	[let aAttribute : EAttribute = aStructuralFeature.oclAsType(EAttribute)]
	[let aDefaultValue : String = aAttribute.getDefaultValue(modules)]
	[if aDefaultValue = '']
	expect(o.[aStructuralFeature.generateGetCall()/]).toBeNull()
	[else]
	expect(o.[aStructuralFeature.generateGetCall()/]).toBe([aDefaultValue/])
	[/if]
	[/let]
	[/let]
})
[/template]


[template private generateGetTestImplementation(aStructuralFeature : EStructuralFeature,aClass : EClass, modules : OclAny)]
[/template]

[template private generateSetTestImplementation(aStructuralFeature : EStructuralFeature,aClass : EClass, modules : OclAny) ?(isVolatile())]
test("set[aStructuralFeature.name.toUpperFirst()/]", () => {
	let o = new [aClass.getImplementationName()/]()
	[aStructuralFeature.eType.generateTestValue('value',modules)/]	
	expect(() => o.[aStructuralFeature.generateSetCall('value')/]).toThrow(Error)
})
[/template]

[template private generateSetTestImplementation(aStructuralFeature : EStructuralFeature,aClass : EClass, modules : OclAny) ?(isContainer())]
[let ecorePrefix : String = if not aClass.ePackage.isEcorePackage() then 'ecore.' else '' endif]
[let reverseFeature : EStructuralFeature = aStructuralFeature.oclAsType(EReference).eOpposite]
[let reverseClass : EClass = reverseFeature.eContainingClass]
test("set[aStructuralFeature.name.toUpperFirst()/]", () => {
	let o = new [aClass.getImplementationName()/]()
	let mockResource = mock<[ecorePrefix/]EResource>()
	let resource = instance(mockResource)
	[aStructuralFeature.eType.generateTestValue('value',modules)/]

	// add listener
	let mockAdapter = mock<[ecorePrefix/]EAdapter>()
	let adapter = instance(mockAdapter)
	o.eAdapters().add(adapter)
	
	// set value
	when(mockValue.eInverseAdd(o,[reverseClass.getImportedIDName(reverseFeature,modules)/],null)).thenReturn(null)
	when(mockValue.eResource()).thenReturn(resource)
	o.[aStructuralFeature.generateSetCall('value')/]
	verify(mockResource.attached(o)).once()
	verify(mockAdapter.notifyChanged(anything())).once()
	{ 
		let ['['/]notification[']'/] = capture(mockAdapter.notifyChanged).last()
		expect(notification.getNotifier()).toBe(o)
		expect(notification.getOldValue()).toBeNull()
		expect(notification.getNewValue()).toBe(value)
	}	
	// set with the same value
	reset(mockAdapter)
	o.[aStructuralFeature.generateSetCall('value')/]
	verify(mockAdapter.notifyChanged(anything())).once()

	// set with another value in a different resource
	[aStructuralFeature.eType.generateTestValue('other',modules)/]
	let mockOtherResource = mock<[ecorePrefix/]EResource>()
	let otherResource = instance(mockOtherResource)
	reset(mockAdapter)
	reset(mockValue)
	reset(mockResource)	
	when(mockValue.eInverseRemove(o,[reverseClass.getImportedIDName(reverseFeature,modules)/],null)).thenReturn(null)
	when(mockValue.eResource()).thenReturn(resource)
	when(mockOther.eInverseAdd(o,[reverseClass.getImportedIDName(reverseFeature,modules)/],null)).thenReturn(null)
	when(mockOther.eResource()).thenReturn(otherResource)
	o.[aStructuralFeature.generateSetCall('other')/]
	verify(mockResource.detached(o)).once()
	verify(mockOtherResource.attached(o)).once()
	verify(mockAdapter.notifyChanged(anything())).once()
	{
		let ['['/]notification[']'/] = capture(mockAdapter.notifyChanged).last()
		expect(notification.getNotifier()).toBe(o)
		expect(notification.getOldValue()).toBe(value)
		expect(notification.getNewValue()).toBe(other)
		expect(notification.getPosition()).toBe(-1)
	}
})
[/let]
[/let]
[/let]
[/template]

[template private generateSetTestImplementation(aStructuralFeature : EStructuralFeature,aClass : EClass, modules : OclAny) ?(isBidirectional())]
[let ecorePrefix : String = if not aClass.ePackage.isEcorePackage() then 'ecore.' else '' endif]
[let reverseFeature : EStructuralFeature = aStructuralFeature.oclAsType(EReference).eOpposite]
[let reverseClass : EClass = reverseFeature.eContainingClass]
test("set[aStructuralFeature.name.toUpperFirst()/]", () => {
	let o = new [aClass.getImplementationName()/]()
	
	// add listener
	let mockAdapter = mock<[ecorePrefix/]EAdapter>()
	let adapter = instance(mockAdapter)
	o.eAdapters().add(adapter)
	
	// first value
	[aStructuralFeature.eType.generateTestValue('value',modules)/]
	when(mockValue.eInverseAdd(o,[reverseClass.getImportedIDName(reverseFeature,modules)/],null)).thenReturn(null)
	o.[aStructuralFeature.generateSetCall('value')/]
	verify(mockAdapter.notifyChanged(anything())).once() 
	{
		let ['['/]notification[']'/] = capture(mockAdapter.notifyChanged).last()
		expect(notification.getNotifier()).toBe(o)
		expect(notification.getOldValue()).toBeNull()
		expect(notification.getNewValue()).toBe(value)
	}

	// set with other value
	[aStructuralFeature.eType.generateTestValue('other',modules)/]
	reset(mockAdapter)
	reset(mockValue)
	when(mockValue.eInverseRemove(o,[reverseClass.getImportedIDName(reverseFeature,modules)/],null)).thenReturn(null)
	when(mockOther.eInverseAdd(o,[reverseClass.getImportedIDName(reverseFeature,modules)/],null)).thenReturn(null)
	o.[aStructuralFeature.generateSetCall('other')/]
	verify(mockAdapter.notifyChanged(anything())).once()
	{
		let ['['/]notification[']'/] = capture(mockAdapter.notifyChanged).last()
		expect(notification.getNotifier()).toBe(o)
		expect(notification.getOldValue()).toBe(value)
		expect(notification.getNewValue()).toBe(other)
		expect(notification.getPosition()).toBe(-1)
	}
})
[/let]
[/let]
[/let]
[/template]

[template private generateSetTestImplementation(aStructuralFeature : EStructuralFeature,aClass : EClass, modules : OclAny)]
[let ecorePrefix : String = if not aClass.ePackage.isEcorePackage() then 'ecore.' else '' endif]
test("set[aStructuralFeature.name.toUpperFirst()/]", () => {
	let o = new [aClass.getImplementationName()/]()
	[aStructuralFeature.eType.generateTestValue('value',modules)/]

	// add listener
	let mockAdapter = mock<[ecorePrefix/]EAdapter>()
	let adapter = instance(mockAdapter)
	o.eAdapters().add(adapter)

	// set value
	o.[aStructuralFeature.generateSetCall('value')/]

	// checks
	verify(mockAdapter.notifyChanged(anything())).once()
	const ['['/]notification[']'/] = capture(mockAdapter.notifyChanged).last()
	expect(notification.getNotifier()).toBe(o)
[let defaultValue : String = aStructuralFeature.getDefaultValue(modules)]
[if defaultValue = 'null']
	expect(notification.getOldValue()).toBeNull()
[else]
	expect(notification.getOldValue()).toBe([defaultValue/])
[/if]
[/let]
	expect(notification.getNewValue()).toBe(value)
	expect(notification.getPosition()).toBe(-1)
})
[/let]
[/template]


[template private generateBasicSetTestImplementation(aStructuralFeature : EStructuralFeature,aClass : EClass, modules : OclAny)]
[let ecorePrefix : String = if not aClass.ePackage.isEcorePackage() then 'ecore.' else '' endif]
test("basicSet[aStructuralFeature.name.toUpperFirst()/]", () => {
	let o = new [aClass.getImplementationName()/]()
	[aStructuralFeature.eType.generateTestValue('value',modules)/]

	// add listener
	let mockAdapter = mock<[ecorePrefix/]EAdapter>()
	let adapter = instance(mockAdapter)
	o.eAdapters().add(adapter)

	// notification chain
	let mockNotifications = mock<[ecorePrefix/]ENotificationChain>()
	let notifications = instance(mockNotifications)

	// set value
[if isContainer()]
	when(mockValue.eResource()).thenReturn(null)
[/if]
	when(mockNotifications.add(anything())).thenReturn(true)
	o.basicSet[aStructuralFeature.getPropertyName().toUpperFirst()/](value,notifications)

	// checks
	verify(mockNotifications.add(anything())).once()
	const ['['/]notification[']'/] = capture(mockNotifications.add).last()
	expect(notification.getNotifier()).toBe(o)
	expect(notification.getEventType()).toBe([ecorePrefix/]EventType.SET)
	expect(notification.getFeatureID()).toBe([aClass.getImportedIDName(aStructuralFeature,modules)/])
[let defaultValue : String = aStructuralFeature.getDefaultValue(modules)]
[if defaultValue = 'null']
	expect(notification.getOldValue()).toBeNull()
[else]
	expect(notification.getOldValue()).toBe([defaultValue/])
[/if]
[/let]
	expect(notification.getNewValue()).toBe(value)
	expect(notification.getPosition()).toBe(-1)
})
[/let]
[/template]

[template private generateUnSetTestImplementation(aStructuralFeature : EStructuralFeature,aClass : EClass, modules : OclAny) ?(isVolatile())]
test("unset[aStructuralFeature.name.toUpperFirst()/]", () => {
	let o = new [aClass.getImplementationName()/]()
	expect(() => o.[aStructuralFeature.getUnSetterName()/]()).toThrow(Error)
})
[/template]

[template private generateUnSetTestImplementation(aStructuralFeature : EStructuralFeature,aClass : EClass, modules : OclAny) ?(isListType())]
test("unset[aStructuralFeature.name.toUpperFirst()/]", () => {
	let o = new [aClass.getImplementationName()/]()
	o.[aStructuralFeature.getUnSetterName()/]()
	expect(o.[aStructuralFeature.generateGetCall()/].isEmpty()).toBeTruthy()
})
[/template]

[template private generateUnSetTestImplementation(aStructuralFeature : EStructuralFeature,aClass : EClass, modules : OclAny)]
[let ecorePrefix : String = if not aClass.ePackage.isEcorePackage() then 'ecore.' else '' endif]
test("unset[aStructuralFeature.name.toUpperFirst()/]", () => {
	let o = new [aClass.getImplementationName()/]()
	
	// add listener
	let mockAdapter = mock<[ecorePrefix/]EAdapter>()
	let adapter = instance(mockAdapter)
	o.eAdapters().add(adapter)

	// unset
	o.[aStructuralFeature.getUnSetterName()/]()

	// checks
	verify(mockAdapter.notifyChanged(anything())).once()
	const ['['/]notification[']'/] = capture(mockAdapter.notifyChanged).last()
	expect(notification.getNotifier()).toBe(o)
	expect(notification.getEventType()).toBe([ecorePrefix/]EventType.UNSET)
	expect(notification.getFeatureID()).toBe([aClass.getImportedIDName(aStructuralFeature,modules)/])	
[let defaultValue : String = aStructuralFeature.getDefaultValue(modules)]
[if defaultValue = 'null']
	expect(o.[aStructuralFeature.generateGetCall()/]).toBeNull()
[else]
	expect(o.[aStructuralFeature.generateGetCall()/]).toBe([defaultValue/])
[/if]
[/let]
})
[/let]
[/template]


[template private generateTestValue(aClass : EClass, varname : String, modules : OclAny )]
let mock[varname.toUpperFirst()/] = mock<[aClass.getInterfaceName()/]Internal>()
let [varname/] = instance(mock[varname.toUpperFirst()/])
[/template]

[template private generateTestValue(aDataType : EDataType, varname : String, modules : OclAny)]
let [varname/] = [aDataType.getTestValue(modules)/]
[/template]

[template private generateTestValue(aEEnum : EEnum, varname : String, modules : OclAny)]
let [varname/] = [aEEnum.getTestValue(modules)/]
[/template]

[template private generateTestValue(aClassifier : EClassifier, varname : String , modules : OclAny)]
let [varname/] = null
[/template]

[template private generateTestOperation(anEOperation : EOperation, aClass : EClass, modules : OclAny )]
test("[anEOperation.getOperationName()/]", () => {
	let o = new([aClass.getImplementationName()/])
	expect(() => o.[anEOperation.getOperationName()/]([for (eClassifier : EClassifier | anEOperation.eParameters.eType) separator(',')][eClassifier.getDefaultValue(modules)/][/for])).toThrow(Error)
})

[/template]

[template private generateElementIDTestImplementation(aClass : EClass, modules : OclAny)]
[let ecorePrefix : String = if not aClass.ePackage.isEcorePackage() then 'ecore.' else '' endif]
[let mixinClasses : Set(EClass) = aClass.getMixinClasses()]
[if mixinClasses->exists( c : EClass | c.getImplementedFeatures()->notEmpty())]
test("eDerivedFeatureID", () => {
	let o = new [aClass.getImplementationName()/]()
	{
		let mockClass = mock<[ecorePrefix/]EClass>()
		let cls = instance(mockClass)
		expect(o.eDerivedFeatureID(cls,1)).toBe(1)
	}
[for (aMixinClass : EClass | mixinClasses)]
	{
		let cls = get[aClass.ePackage.getInterfaceName()/]().get[aMixinClass.getElementAccessorName()/]()
		expect(o.eDerivedFeatureID(cls,-1)).toBe(-1)
	[for (aFeature : EStructuralFeature | aMixinClass.getImplementedFeatures() )]
		expect(o.eDerivedFeatureID(cls,[aMixinClass.getImportedIDName(aFeature,modules)/])).toBe([aClass.getImportedIDName(aFeature,modules)/])
	[/for]
	}
[/for]
})
[/if]

[if mixinClasses->exists( c : EClass | c.getImplementedOperations()->notEmpty())]
test("eDerivedOperationID", () => {
	let o = new [aClass.getImplementationName()/]()
	{
		let mockClass = mock<[ecorePrefix/]EClass>()
		let cls = instance(mockClass)
		expect(o.eDerivedOperationID(cls,1)).toBe(1)
	}
[for (aMixinClass : EClass | mixinClasses)]
	{
		let cls = get[aClass.ePackage.getInterfaceName()/]().get[aMixinClass.getElementAccessorName()/]()
		expect(o.eDerivedOperationID(cls,-1)).toBe(-1)
	[for (aOperation : EOperation | aMixinClass.getImplementedOperations() )]
		expect(o.eDerivedOperationID(cls,[aMixinClass.getImportedIDName(aOperation,modules)/])).toBe([aClass.getImportedIDName(aOperation,modules)/])
	[/for]
	}
[/for]
})
[/if]
[/let]
[/let]
[/template]

[template private generateEGetFromIDTestImplementation(aClass : EClass, modules : OclAny)]
[let ecorePrefix : String = if not aClass.ePackage.isEcorePackage() then 'ecore.' else '' endif]
[let features : OrderedSet(EStructuralFeature) = aClass.getEGetFeatures()->asOrderedSet()->sortedBy(name)]
[if features->notEmpty()]
test("eGetFromID", () => {
	let o = new [aClass.getImplementationName()/]()
	expect(() => o.eGetFromID(-1,true)).toThrow(Error)
	[for (anStructFeature : EStructuralFeature | features )]
	[if anStructFeature.isVolatile() or ( anStructFeature.hasInitializationMethod() and anStructFeature.oclIsKindOf(EReference) and not anStructFeature.isListType() and not anStructFeature.isProxy() )  ]
	expect(() => o.eGetFromID([aClass.getImportedIDName(anStructFeature,modules)/],true)).toThrow(Error)
	expect(() => o.eGetFromID([aClass.getImportedIDName(anStructFeature,modules)/],false)).toThrow(Error)
	[else]
	expect(o.eGetFromID([aClass.getImportedIDName(anStructFeature,modules)/],true)).toStrictEqual(o.[anStructFeature.generateGetCall()/])
	[if (not anStructFeature.isMapType() and anStructFeature.isListType() and anStructFeature.oclIsKindOf(EReference))]
	expect(
		deepEqual(
			o.eGetFromID([aClass.getImportedIDName(anStructFeature,modules)/],false),
			(o.[anStructFeature.generateGetCall()/] as [ecorePrefix/]EObjectList<[anStructFeature.eGenericType.generateListTypeParameters(modules)/]>).getUnResolvedList()
		)
	).toBeTruthy()
	[/if]
	[/if]
    [/for]
})
[/if]
[/let]
[/let]
[/template]

[template private generateFeatureESetFromIDTestImplementation(anStructuralFeature : EStructuralFeature ,aClass : EClass, modules : OclAny) ? (isVolatile())]
expect(() => o.eSetFromID([aClass.getImportedIDName(anStructuralFeature,modules)/],null)).toThrow(Error)

[/template]

[template private generateFeatureESetFromIDTestImplementation(anStructuralFeature : EStructuralFeature ,aClass : EClass, modules : OclAny) ? (isContainer())]
{
[let reverseFeature : EStructuralFeature = anStructuralFeature.oclAsType(EReference).eOpposite]
[let reverseClass : EClass = reverseFeature.eContainingClass]
	[anStructuralFeature.eType.generateTestValue('value',modules)/]
	when(mockValue.eIsProxy()).thenReturn(false)
	when(mockValue.eResource()).thenReturn(null)
	when(mockValue.eInverseAdd(o,[reverseClass.getImportedIDName(reverseFeature,modules)/],null)).thenReturn(null)
	o.eSetFromID([aClass.getImportedIDName(anStructuralFeature,modules)/], value)
	expect(o.eGetFromID([aClass.getImportedIDName(anStructuralFeature,modules)/], false)).toBe(value)
	verify(mockValue.eIsProxy()).once()
	verify(mockValue.eResource()).once()
	verify(mockValue.eInverseAdd(o,[reverseClass.getImportedIDName(reverseFeature,modules)/],null)).once()
[/let]
[/let]	
}

[/template]

[template private generateFeatureESetFromIDTestImplementation(anStructuralFeature : EStructuralFeature ,aClass : EClass, modules : OclAny) ? (isMapType() and anStructuralFeature.eType.oclIsKindOf(EClass) and anStructuralFeature.eType.oclAsType(EClass).isMapEntry())]
{
[let aPackage : EPackage = aClass.ePackage]
[let ecorePrefix : String = if not aPackage.isEcorePackage() then 'ecore.' else '' endif]
[let aMapClass : EClass = anStructuralFeature.eType.oclAsType(EClass)]
[let keyFeature : EStructuralFeature = aMapClass.getEStructuralFeature('key')]
[let valueFeature : EStructuralFeature = aMapClass.getEStructuralFeature('value')]
	let mockMap = mock<[ecorePrefix/]EMap<[anStructuralFeature.eGenericType.generateMapTypeParameters(modules)/]>>()
	let map = instance(mockMap)
	let mockIterator = mock<Iterator<[ecorePrefix/]EMapEntry<[anStructuralFeature.eGenericType.generateMapTypeParameters(modules)/]>>>()
	let iterator = instance(mockIterator)
	let mockEntry = mock<[ecorePrefix/]EMapEntry<[anStructuralFeature.eGenericType.generateMapTypeParameters(modules)/]>>()
	let entry = instance(mockEntry)
	[keyFeature.eType.generateTestValue('key',modules)/]
	[valueFeature.eType.generateTestValue('value',modules)/]
	when(mockMap['['/]Symbol.iterator[']'/]()).thenReturn(iterator)
	when(mockIterator.next()).thenReturn({ value: entry, done: false } ).thenReturn({ value: undefined, done: true })
	when(mockEntry.key).thenReturn(key)
	when(mockEntry.value).thenReturn(value)
	o.eSetFromID([aClass.getImportedIDName(anStructuralFeature,modules)/], map)
	expect(o.[anStructuralFeature.generateGetCall()/].toMap()).toEqual(new Map<[anStructuralFeature.eGenericType.generateMapTypeParameters(modules)/]>(['['/]['['/]key,value[']'/][']'/]))
[/let]
[/let]
[/let]
[/let]
[/let]
}

[/template]

[template private generateFeatureESetFromIDTestImplementation(anStructuralFeature : EStructuralFeature ,aClass : EClass, modules : OclAny) ? (isMapType())]
[/template]

[template private generateFeatureESetFromIDTestImplementation(anStructuralFeature : EStructuralFeature ,aClass : EClass, modules : OclAny) ? (isListType() and oclIsKindOf(EReference))]
[let ecorePrefix : String = if not aClass.ePackage.isEcorePackage() then 'ecore.' else '' endif]
{
	// list with a value
	[anStructuralFeature.eType.generateTestValue('value',modules)/]
	let l = new [ecorePrefix/]ImmutableEList<[anStructuralFeature.eGenericType.generateListTypeParameters(modules)/]>(['['/]value[']'/])
[if anStructuralFeature.isProxy()]
	when(mockValue.eIsProxy()).thenReturn(false)
[/if]
	[anStructuralFeature.generateFeatureMockAddedExpectations('mockValue',aClass,modules)/]
	// set list with new contents
	o.eSetFromID([aClass.getImportedIDName(anStructuralFeature,modules)/], l)
	// checks
	expect(o.[anStructuralFeature.generateGetCall()/].size()).toBe(1)
	expect(o.[anStructuralFeature.generateGetCall()/].get(0)).toBe(value)
	[anStructuralFeature.generateFeatureMockAddedVerifications('mockValue',aClass,modules)/]
}

[/let]
[/template]

[template private generateFeatureMockAddedExpectations(anStructuralFeature : EStructuralFeature , mockName : String , aClass : EClass, modules : OclAny)]
[if anStructuralFeature.isContains()]
	[let anEReference : EReference = anStructuralFeature.oclAsType(EReference)]
	[if anEReference.eOpposite.oclIsUndefined()]
when([mockName/].eInverseAdd(o,[if not aClass.ePackage.isEcorePackage()]ecore.[/if]EOPPOSITE_FEATURE_BASE - [aClass.getImportedIDName(anStructuralFeature,modules)/],anything())).thenReturn(null)
	[else]
	[let reverseFeature : EStructuralFeature = anStructuralFeature.oclAsType(EReference).eOpposite]
	[let reverseClass : EClass = reverseFeature.eContainingClass]
when([mockName/].eInverseAdd(o,[reverseClass.getImportedIDName(reverseFeature,modules)/],anything())).thenReturn(null) 
	[/let]
	[/let]
	[/if]
	[/let]
[elseif anStructuralFeature.oclIsKindOf(EReference)]
	[let anEReference : EReference = anStructuralFeature.oclAsType(EReference)]
	[if anEReference.eOpposite.oclIsUndefined()]
	[else]
	[let reverseFeature : EStructuralFeature = anStructuralFeature.oclAsType(EReference).eOpposite]
	[let reverseClass : EClass = reverseFeature.eContainingClass]
when([mockName/].eInverseAdd(o,[reverseClass.getImportedIDName(reverseFeature,modules)/],anything())).thenReturn(null) 
	[/let]
	[/let]
	[/if]
	[/let]
[/if]
[/template]


[template private generateFeatureMockAddedVerifications(anStructuralFeature : EStructuralFeature , mockName : String , aClass : EClass, modules : OclAny)]
[if anStructuralFeature.isContains()]
	[let anEReference : EReference = anStructuralFeature.oclAsType(EReference)]
	[if anEReference.eOpposite.oclIsUndefined()]
verify([mockName/].eInverseAdd(o,[if not aClass.ePackage.isEcorePackage()]ecore.[/if]EOPPOSITE_FEATURE_BASE - [aClass.getImportedIDName(anStructuralFeature,modules)/],anything())).once()
	[else]
	[let reverseFeature : EStructuralFeature = anStructuralFeature.oclAsType(EReference).eOpposite]
	[let reverseClass : EClass = reverseFeature.eContainingClass]
verify([mockName/].eInverseAdd(o,[reverseClass.getImportedIDName(reverseFeature,modules)/],anything())).once()
	[/let]
	[/let]
	[/if]
	[/let]
[elseif anStructuralFeature.oclIsKindOf(EReference)]
	[let anEReference : EReference = anStructuralFeature.oclAsType(EReference)]
	[if anEReference.eOpposite.oclIsUndefined()]
	[else]
	[let reverseFeature : EStructuralFeature = anStructuralFeature.oclAsType(EReference).eOpposite]
	[let reverseClass : EClass = reverseFeature.eContainingClass]
verify([mockName/].eInverseAdd(o,[reverseClass.getImportedIDName(reverseFeature,modules)/],anything())).once()
	[/let]
	[/let]
	[/if]
	[/let]
[/if]
[/template]

[template private generateFeatureESetFromIDTestImplementation(anStructuralFeature : EStructuralFeature ,aClass : EClass, modules : OclAny) ? (isListType())]
[let ecorePrefix : String = if not aClass.ePackage.isEcorePackage() then 'ecore.' else '' endif]
{
	let l = new [ecorePrefix/]ImmutableEList<[anStructuralFeature.eGenericType.generateListTypeParameters(modules)/]>()
	o.eSetFromID([aClass.getImportedIDName(anStructuralFeature,modules)/], l)
	expect(o.[anStructuralFeature.generateGetCall()/].isEmpty()).toBeTruthy()
}
[/let]

[/template]

[template private generateFeatureESetFromIDTestImplementation(anStructuralFeature : EStructuralFeature ,aClass : EClass, modules : OclAny) ? (isBidirectional())]
{
[let reverseFeature : EStructuralFeature = anStructuralFeature.oclAsType(EReference).eOpposite]
[let reverseClass : EClass = reverseFeature.eContainingClass]
	[anStructuralFeature.eType.generateTestValue('value',modules)/]
	when(mockValue.eInverseAdd(o,[reverseClass.getImportedIDName(reverseFeature,modules)/],null)).thenReturn(null)	
	o.eSetFromID([aClass.getImportedIDName(anStructuralFeature,modules)/], value)
	expect(o.eGetFromID([aClass.getImportedIDName(anStructuralFeature,modules)/], false)).toBe(value)
	verify(mockValue.eInverseAdd(o,[reverseClass.getImportedIDName(reverseFeature,modules)/],null)).once()
[/let]
[/let]
}

[/template]

[template private generateFeatureESetFromIDTestImplementation(anStructuralFeature : EStructuralFeature ,aClass : EClass, modules : OclAny) ? (isContains())]
{
	[anStructuralFeature.eType.generateTestValue('value',modules)/]
	when(mockValue.eInverseAdd(o,[if not aClass.ePackage.isEcorePackage()]ecore.[/if]EOPPOSITE_FEATURE_BASE - [aClass.getImportedIDName(anStructuralFeature,modules)/],anything())).thenReturn(null)
	o.eSetFromID([aClass.getImportedIDName(anStructuralFeature,modules)/], value)
	expect(o.eGetFromID([aClass.getImportedIDName(anStructuralFeature,modules)/], false)).toBe(value)
	verify(mockValue.eInverseAdd(o,[if not aClass.ePackage.isEcorePackage()]ecore.[/if]EOPPOSITE_FEATURE_BASE - [aClass.getImportedIDName(anStructuralFeature,modules)/],anything())).once()
}

[/template]

[template private generateFeatureESetFromIDTestImplementation(anStructuralFeature : EStructuralFeature ,aClass : EClass, modules : OclAny)]
{
	[anStructuralFeature.eType.generateTestValue('value',modules)/]	
	o.eSetFromID([aClass.getImportedIDName(anStructuralFeature,modules)/], value)
	expect(o.eGetFromID([aClass.getImportedIDName(anStructuralFeature,modules)/], false)).toBe(value)
}

[/template]

[template private generateESetFromIDTestImplementation(aClass : EClass, modules : OclAny)]
[let aPackage : EPackage = aClass.ePackage ]
[let features : OrderedSet(EStructuralFeature) = aClass.getESetFeatures()->select(not isFeatureMap())->asOrderedSet()->sortedBy(name)]
[if features->notEmpty()]
test("eSetFromID", () => {
	let o = new [aClass.getImplementationName()/]()
	expect(() => o.eSetFromID(-1,null)).toThrow(Error)
	[features.generateFeatureESetFromIDTestImplementation(aClass,modules)/]
})
[/if]
[/let]
[/let]
[/template]

[template private generateEIsSetFromIDTestImplementation(aClass : EClass, modules : OclAny)]
[let features : OrderedSet(EStructuralFeature) = aClass.getEIsSetFeatures()->select(not isFeatureMap())->asOrderedSet()->sortedBy(name)]
[if features->notEmpty()]
test("eIsSetFromID", () => {
	let o = new [aClass.getImplementationName()/]()
	expect(() => o.eIsSetFromID(-1)).toThrow(Error)
	[for (anStructFeature : EStructuralFeature | features)]
		[if anStructFeature.isVolatile()]
	expect(() => o.eIsSetFromID([aClass.getImportedIDName(anStructFeature,modules)/])).toThrow(Error)
		[else]
	expect(o.eIsSetFromID([aClass.getImportedIDName(anStructFeature,modules)/])).toBeFalsy()
		[/if]		
	[/for]
})
[/if]
[/let]
[/template]


[template private generateEUnSetFromIDTestImplementation(aClass : EClass, modules : OclAny)]
[let features : OrderedSet(EStructuralFeature) = aClass.getEUnSetFeatures()->select(not isFeatureMap())->asOrderedSet()->sortedBy(name)]
[if features->notEmpty()]
test("eUnsetFromID", () => {
	let o = new [aClass.getImplementationName()/]()
	expect(() => o.eUnsetFromID(-1)).toThrow(Error)
	[for (anStructFeature : EStructuralFeature | features)]
	{
	[if anStructFeature.isVolatile()]
		expect(() => o.eUnsetFromID([aClass.getImportedIDName(anStructFeature,modules)/])).toThrow(Error)
	[else]
		o.eUnsetFromID([aClass.getImportedIDName(anStructFeature,modules)/])
		[if anStructFeature.isListType()]
		let v = o.eGetFromID([aClass.getImportedIDName(anStructFeature,modules)/], false)
		expect(v).not.toBeNull()
		let l = v as [if not aClass.ePackage.isEcorePackage()]ecore.[/if]EList<[anStructFeature.eGenericType.generateListTypeParameters(modules)/]> 
		expect(l.isEmpty()).toBeTruthy()
		[elseif anStructFeature.oclIsKindOf(EReference)]
		expect(o.eGetFromID([aClass.getImportedIDName(anStructFeature,modules)/], false)).toBeNull()
		[else]
			[let aAttribute : EAttribute = anStructFeature.oclAsType(EAttribute)]
			[let defaultValue : String = aAttribute.getDefaultValue(modules)]
			[if defaultValue <> '']
		let v = o.eGetFromID([aClass.getImportedIDName(anStructFeature,modules)/], false)
			[if defaultValue = 'null']
		expect(v).toBeNull()
			[else]
		expect(v).toBe([defaultValue/])
			[/if]	
			[else]
			[/if]
			[/let]
			[/let]
		[/if]
	[/if]
	}
	[/for]
})
[/if]
[/let]
[/template]

[template private generateEInverseAddTestImplementation(aClass : EClass, modules : OclAny)]
[let ecorePrefix : String = if not aClass.ePackage.isEcorePackage() then 'ecore.' else '' endif]
[let features : OrderedSet(EStructuralFeature) = aClass.getEInverseAddFeatures()->asOrderedSet()->sortedBy(name)]
[if features->notEmpty()]
test("eBasicInverseAdd", () => {
	let o = new [aClass.getImplementationName()/]()
	{
		let mockObject = mock<[ecorePrefix/]EObject>()
		let object = instance(mockObject)
		let mockNotifications = mock<[ecorePrefix/]ENotificationChain>() 
		let notifications = instance(mockNotifications)
		expect(o.eBasicInverseAdd(object,-1,notifications)).toBe(notifications)
	}
	[features.generateFeatureEInverseAddTestImplementation(aClass,modules)/]
})
[/if]
[/let]
[/let]
[/template]

[template private generateFeatureEInverseAddTestImplementation( aStructuralFeature : EStructuralFeature, aClass : EClass , modules : OclAny) ?(isMapType())]
[/template]

[template private generateFeatureEInverseAddTestImplementation( aStructuralFeature : EStructuralFeature, aClass : EClass , modules : OclAny ) ?(isListType())]
{
	[aStructuralFeature.eType.generateTestValue('value',modules)/]
	o.eBasicInverseAdd(value,[aClass.getImportedIDName(aStructuralFeature,modules)/],null)
	expect(o.[aStructuralFeature.generateGetCall()/].contains(value)).toBeTruthy()
}

[/template]

[template private generateFeatureEInverseAddTestImplementation( aStructuralFeature : EStructuralFeature, aClass : EClass , modules : OclAny) ?(isContainer())]
{
	[aStructuralFeature.eType.generateTestValue('value',modules)/]
	when(mockValue.eResource()).thenReturn(null)
	when(mockValue.eIsProxy()).thenReturn(false)
	o.eBasicInverseAdd(value,[aClass.getImportedIDName(aStructuralFeature,modules)/],null)
	expect(o.[aStructuralFeature.generateGetCall()/]).toBe(value)

	reset(mockValue)
	[aStructuralFeature.eType.generateTestValue('other',modules)/]
	when(mockOther.eResource()).thenReturn(null)
	when(mockOther.eIsProxy()).thenReturn(false)
	when(mockValue.eResource()).thenReturn(null)
[if aStructuralFeature.isContains()]
	when(mockValue.eInverseRemove(o,[if not aClass.ePackage.isEcorePackage()]ecore.[/if]EOPPOSITE_FEATURE_BASE - [aClass.getImportedIDName(aStructuralFeature,modules)/],null)).thenReturn(null)
[else]
	[let reverseFeature : EStructuralFeature = aStructuralFeature.oclAsType(EReference).eOpposite]
	when(mockValue.eInverseRemove(o,[reverseFeature.eContainingClass.getImportedIDName(reverseFeature,modules)/],null)).thenReturn(null)
	[/let]
[/if]
	o.eBasicInverseAdd(other,[aClass.getImportedIDName(aStructuralFeature,modules)/],null)
	expect(o.[aStructuralFeature.generateGetCall()/]).toBe(other)
}

[/template]

[template private generateFeatureEInverseAddTestImplementation( aStructuralFeature : EStructuralFeature, aClass : EClass , modules : OclAny)]
{
	[aStructuralFeature.eType.generateTestValue('value',modules)/]
[if aStructuralFeature.isProxy()]
	when(mockValue.eIsProxy()).thenReturn(false)
[/if]
	o.eBasicInverseAdd(value,[aClass.getImportedIDName(aStructuralFeature,modules)/],null)
	expect(o.[aStructuralFeature.generateGetCall()/]).toBe(value)

	reset(mockValue)
	[aStructuralFeature.eType.generateTestValue('other',modules)/]
[if aStructuralFeature.isProxy()]
	when(mockOther.eIsProxy()).thenReturn(false)
[/if]
[if aStructuralFeature.isContains()]
	when(mockValue.eInverseRemove(o,[if not aClass.ePackage.isEcorePackage()]ecore.[/if]EOPPOSITE_FEATURE_BASE - [aClass.getImportedIDName(aStructuralFeature,modules)/],null)).thenReturn(null)
[else]
	[let reverseFeature : EStructuralFeature = aStructuralFeature.oclAsType(EReference).eOpposite]
	when(mockValue.eInverseRemove(o,[reverseFeature.eContainingClass.getImportedIDName(reverseFeature,modules)/],null)).thenReturn(null)
	[/let]
[/if]
	o.eBasicInverseAdd(other,[aClass.getImportedIDName(aStructuralFeature,modules)/],null)
	expect(o.[aStructuralFeature.generateGetCall()/]).toBe(other)
}

[/template]


[template private generateEInverseRemoveTestImplementation(aClass : EClass, modules : OclAny)]
[let ecorePrefix : String = if not aClass.ePackage.isEcorePackage() then 'ecore.' else '' endif]
[let features : OrderedSet(EStructuralFeature) = aClass.getEInverseRemoveFeatures()->asOrderedSet()->sortedBy(name)]
[if features->notEmpty()]
test("eBasicInverseRemove", () => {
	let o = new [aClass.getImplementationName()/]()
	{
		let mockObject = mock<[ecorePrefix/]EObject>()
		let object = instance(mockObject)
		let mockNotifications = mock<[ecorePrefix/]ENotificationChain>() 
		let notifications = instance(mockNotifications)
		expect(o.eBasicInverseRemove(object,-1,notifications)).toBe(notifications)
	}
	[features.generateFeatureEInverseRemoveTestImplementation(aClass,modules)/]
})
[/if]
[/let]
[/let]
[/template]

[template private generateFeatureEInverseRemoveTestImplementation( aStructuralFeature : EStructuralFeature, aClass : EClass , modules : OclAny) ?(isMapType())]
{
	[aStructuralFeature.eType.generateTestValue('value',modules)/]
	o.eBasicInverseRemove(mockValue,[aClass.getImportedIDName(aStructuralFeature,modules)/],null)
	expect(o.[aStructuralFeature.generateGetCall()/].isEmpty())
}

[/template]

[template private generateFeatureEInverseRemoveTestImplementation( aStructuralFeature : EStructuralFeature, aClass : EClass , modules : OclAny) ?(isListType())]
{
	// initialize list with a mock object
	[aStructuralFeature.eType.generateTestValue('value',modules)/]
	[aStructuralFeature.generateFeatureMockAddedExpectations('mockValue',aClass,modules)/]
	o.[aStructuralFeature.generateGetCall()/].add(value)

	// basic inverse remove
	o.eBasicInverseRemove(value,[aClass.getImportedIDName(aStructuralFeature,modules)/],null)

	// check it was removed
	expect(o.[aStructuralFeature.generateGetCall()/].contains(value)).toBeFalsy()
}

[/template]

[template private generateFeatureEInverseRemoveTestImplementation( aStructuralFeature : EStructuralFeature, aClass : EClass , modules : OclAny)]
{
	[aStructuralFeature.eType.generateTestValue('value',modules)/]
	o.eBasicInverseRemove(value,[aClass.getImportedIDName(aStructuralFeature,modules)/],null)	
}

[/template]

[template private generateEInvokeFromIDTestImplementation(aClass : EClass, modules : OclAny)]
[let operations : OrderedSet(EOperation) = aClass.getEInvokeOperations()->asOrderedSet()->sortedBy( o | o.eContainingClass.getOperationIDName(o))]
[if aClass.name <> 'EObject' and operations->notEmpty()]
test("eInvokeFromID", () => {
	let o = new [aClass.getImplementationName()/]()
	expect(() => o.eInvokeFromID(-1,null)).toThrow(Error)
	[for ( eOperation : EOperation | operations )]
	expect(() => o.eInvokeFromID([eOperation.eContainingClass.getImportedIDName(eOperation,modules)/],null)).toThrow(Error)
	[/for]
})
[/if]
[/let]
[/template]




